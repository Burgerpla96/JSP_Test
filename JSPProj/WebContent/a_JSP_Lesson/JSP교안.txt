[웹 컨테이너] 

	- 웹 어플리케이션을 실행 할 수 있는 컨테이너
	- Servlet컨테이너와 JSP컨테이너를 합쳐서 웹 컨테이라고 함
	- 일종의 WAS역할 을 함
	- 종류로는 오픈 소스 웹 컨테이너인 Tomcat,Jetty등이 있고 상용인 Weblogic,WebShpere,JBoss등이
	  있다.
	- Tomcat는 가벼운 WAS(Web Application Server)역할을 한다고 볼 수 있다.	
	
	/*
	Tomcat => Servlet과  JSP 를 담는 그릇(컨테이너)
	WAS (Web Application Server) => JBOSS, ....
	Tomcat은 진정한 의미의 WAS는 아니다. 단지, 컨테이너
	tomcat은 was서버에 함수 등록이 안된다.
	*/


	Tomcat버전 종류]
	
			-----------------+-------------------------+-------------------------+----------------------------
		  Servlet/JSP Spec   | Apache Tomcat version    | Actual release revision      | Minimum Java Version(JDK)
			-----------------+-------------------------+-------------------------+----------------------------
	   3.1/2.3               |       9.0.x                          |    9.0.0                         |           1.6 
	   3.1/2.3               |       8.0.x                          |    8.0.37                          |           1.6 
	   3.0/2.2               |       7.0.x                          |    7.0.26                           |           1.6 
	   2.5/2.1               |       6.0.x                          |    6.0.35                           |           1.5 
	   2.4/2.0               |       5.5.x                          |    5.5.35                           |           1.4 
	   2.3/1.2               |       4.1.x (archived)          |    4.1.40 (archived)           |           1.3 
	   2.2/1.1               |       3.3.x (archived)          |    3.3.2 (archived)              |           1.1 
            -----------------+-------------------------+-------------------------+-----------------------



	[주요 설정파일]
	-Tomcat설치된 디렉토리\conf 
		
		-server.xml]
		
			- 포트를 변경하거나(<Connector>엘리먼트의 port속성에서 변경)
				  <Connector port="8080" protocol="HTTP/1.1" 
					connectionTimeout="20000" 
					redirectPort="8443" />

			
			- 홈디렉토리를 변경하거나(<Host>엘리먼트의 appBase속성에서 변경)
				<Host name="localhost"  appBase="webapps"...
			
			- Tomcat서버에  실행중인 context를 등록하거나(<Host>엘리먼트 사이에</Host>
			   <Host>
				   <Context docBase="JspProj" 
				   path="/JspProj" 
				   reloadable="true" 
				   source="org.eclipse.jst.jee.server:JspProj"/>
			   </Host>	
			   단, 위코드는 jsp파일을 실행시키면 자동으로 등록 됨.

			   Path속성의  /만 남겨두면 링크시 프로젝트명을 명시할 필요 없다.

			   <a href="/JspProj/form.jsp"> --><a href="/form.jsp">
			   reloadable="true" 는 context영역의 web.xml을 변경하거나
			   서블릿코드를 변경하는 경우 자동으로 서버를 restart하도록 설정하는 것임

		-web.xml]

			- 시작 문서를 설정하거나

				 <welcome-file-list>
					<welcome-file>index.html</welcome-file>
					<welcome-file>index.htm</welcome-file>
					<welcome-file>index.jsp</welcome-file>
				 </welcome-file-list>

			- 서블릿을 등록하거나
				<servlet>
					<servlet-name>서블릿명</servlet-name>
					<servlet-class>서블릿클래스의 Qualified경로(즉 패키지를 포함한 경로)</servlet-class>
				</servlet>

				<servlet-mapping>
					<servlet-name>서블릿명</servlet-name>
					<url-pattern>
						/로 시작하는 요청명					
					</url-pattern>
				</servlet-mapping>

			- 세션 유지 시간을 설정하거나
				<session-config>
					<session-timeout>30</session-timeout>
				</session-config>

		-context.xml]

			- 톰캣서버에 서 실행중인 모든 context(즉 웹 어플리케이션)에 
			  공통으로 적용할 속성등을 지정할 수 있다.

			  예]

			  <Context reloadable="true">

			  </Context>
[서블릿_Servlet]@@@

		
		* 서블릿은 (1)사용자의 요청(request)을 받아서 (2)요청을 분석한후 그 요청에 맞는
		  (3)비즈니스 로직(Model이 갖고잇음)을 호출하고 (4)Model로부터 그 결과값을 
		  받아서 (5)request나 session영역에 저장하고(대부분 request에 저장)
		  결과값을 뿌려줄 적절한 view(jsp페이지)를 선택하는 역할을 담당한다.
		  최종적으로 선택된 view(jsp페이지)가 요청한 사용자에게 전달(response)된다
		  

		- 서블릿은 MVC모델에서 Controller에 해당한다. servlet이 model과 view선택
		- 서블릿은 Servlet interface를 implements하여 생성한 자바 클래스이다.
		- 서블릿은 서블릿 엔진에 의해 구동된다.
		- 서블릿의 모든 메소드는 쓰레드로 동작된다
		- 서블릿은 JSP의 기반 기술이다.
		- 서블릿이나 JSP등은 Java To Enterprise Edition(J2EE)이다

		- 서블릿의 처리 과정

							   request(1)         (Tomcat)                   (2)  모델호출
			Web Browser   ----------------------->Servlet컨테이너(서블릿 클래스)<----------------->DB Server
				   ▲                                 |
				   |			response(4)    	     | View선택(3)
				   +---------------------------------+
						

		- WAS 서버들의 공콩적인 디렉토리 구조

			 :JAVA는 CLASS파일이 실행되는 것이기때문에 이를 위해 
			  WAS서버들은 아래와 같은 공통적인 구조(서블릿 규약)를 갖는다




WebContent 는 실제 WAR로 배포할때는 안보이게 된다.
Eclipse 에서 WebContent관리를 위한 파일이다.

jsp파일을 WEB-INF에 넣으면 경로가 올바르더라도 실행이 안된다.



				Context Root
					|
					+--------WEB-INF
					            |
								+---------classes폴더 (여기에 클래스 파일들이 위치한다)
								|
								+---------lib폴더 (jar파일이 위치)
								|
								+---------src폴더(java파일이 위치)
								|
								web.xml파일
					
					Context Root밑에는 jsp/html/css/js/이미지파일(jpg.gif등)등이 위치한다.

					*서블릿2.4/jsp2.0규약은 web.xml을 반드시 포함하도록 규정하고 있음.
					하지만 서블릿2.5/jsp2.1구약부터는 
					단순히 jsp로만 구성된 웹 어플리케이션인 경우
					포함 하지 않아도 됨
					단, 서블릿을 설정하고자 할때는 web.xml을 포함 해야 한다.
					
       [Tomcat이 설치된 디렉토리/conf에 있는 주요 설정 파일]	
		-설정파일들을 수정한 후에는 톰캣을 항상 재시작 해야 한다.

		[server.xml]-Tomcat서버에 대한 환경설정 파일
		
			:톰캣의 HTTP 포트 서비스를 변경하거나 한글 설정 그리고 Context ROOT 디렉토리 변경 등..
			
			주의] 한글 주석을 달면 톰캣이 실행이 안된다.

			프토 설정]
		
				-<Connector>엘리먼트의  port 속성을 수정
				-톰캣 재시작
			
			한글 설정]

				-POST방식으로 넘어온 데이타중 한글이 깨지는 거를 막기 위한 설정
				JSP소스에서 직접  request.setCharacterEncoding("UTF-8");

									


			Context ROOT 디렉토리 설정]
			
				-<Host>엘리먼트의 appBase속성 수정

				예]

				 <Host name="localhost"  appBase="D:\webApps"
				    unpackWARs="true" autoDeploy="true"
				    xmlValidation="false" xmlNamespaceAware="false">



		[web.xml]

            내 웹 어플리케이션-WEB-INF-web.xml:내 어플리케이션만을 위한 환경 설정 파일
            servers탭-web.xml :해당 서버를 사용하는 모든 웹 어플리케이션에 공통으로 적용되는 환경설정파일


			- 시작 문서를 설정할 수 있다.
			- servlet을 매핑할 수 있다.
		

			예]
			<welcome-file-list>
				<welcome-file>index.html</welcome-file>
				<welcome-file>index.htm</welcome-file>
				<welcome-file>index.jsp</welcome-file>
			</welcome-file-list>

			
			 
			 .do라는 확장자를 가진 파일을 서블릿 엔진에게 처리하라는 의미
			 즉 파일 작성후 확장자를 .do로 저장하면 서블릿 엔진이 컴파일 한다.

			 <servlet-mapping>
				<servlet-name>jsp</servlet-name>
				<url-pattern>*.do</url-pattern>
			 </servlet-mapping>

			

		[context.xml]

			- Context안의 내용이 변경되면 즉 서블릿이나 JSP 혹은 web.xml 변경시  자동으로 재 로딩 하도록 설정
			  즉  톰캣을 재시작 하지 않도록 하기 위한 설정

			<Context reloadable="true">  
			</Context>


		- 서블릿 작성 규칙 및 테스트


			1) javax.servlet 패키지 와 javax.servlet.http패키지 
			   그리고 java.io패키지를 기본적으로 import한다.
			2) 클래스명 앞에 public 을 반드시 붙인다.
			3) 서블릿은 extends HttpServlet을 상속 받아야 한다.
			4) ServletException,IOException 예외를 선언해 줘야 한다
			5) doGet()메서드 나 doPost()메서드 메서드를 반드시 오버라이딩 해야한다.
			6) 서블릿 엔진은 사용자의 요청을 받았을때 서블릿 클래스에 정의 되어 있는
			   doGet() 또는 doPost() 메소드를 호출한다.
			   파라미터는 HttpServletRequest, HttpServletResponse 두개의 클래스를 사용한다.
			  
	
			       
				doGet():  GET방식으로 서블릿을 요청하는 경우.
				              웹 브라우저에서 서블릿을 호출하는 대부분의 호출 방식(GET방식)
				               GET 방식으로 호출된 서블릿은 
					       서블릿 엔진이 서블릿의 doGet() 함수를 호출한다.

				doPost(): POST 방식으로 서블릿을 요청하는 경우.
				          반드시 form요소를 사용하여 서블릿을 호출한다.
				          POST 방식으로 호출된 서블릿은 서블릿 엔진이 서블릿의 
					  doPost() 함수를 호출한다.


				HttpServletRequest:

					사용자의 정보를 서블릿 엔진에 전달하는 객체
						-파라미터의 이름과 값
						-사용자 컴퓨터의 이름
						-요청을 받는 서버의 이름
						-input type의 데이터

					주요 메서드
						- getParameterValues(String name)
						- getParameter(String name)
						- getRemoteHost()
						- getServerName()

				HttpServletResponse:

					서버에서 응답으로 만들어진 정보를 암호화 하여 사용자에게 전달한다.
						- 응답으로 사용되는 content의 길이
						- 응답으로 사용되는 content의 타입
						- 화면에 출력하여야 하는 모든 값.


					주요 메서드

						-setContentLength(int length)
						-setContentType(String type)
						-getWriter()

						
				
			    오버라이딩 형식]

				public void doGet(HttpServletRequest req,HttpServletResponse res)
					throws ServletException	
				{

				}

				

				[HTTP상의 데이터 전송 방식]
					
					가) GET 방식: 
						- http 헤더에 정보를 전달
						- 기본 정보 전달 방식
						- URL뒤에 이름=값의 형태로 정보 전달, 여러개의 값을 전달할때는 & 로 연결
						- 최대 4kb까지 전달
						
					나) POST 방식

						- http Body에 정보를 전달
						- 데이터 사이즈에 제한이 없음
					    - URL에 노출이 안되기때문에 보안이 GET방식보다 우수
	

       
		- 서블릿의 라이프 사이클

			* 생명주기에 관한 모든 메서드는 서블릿 엔진이 호출한다. 개발자가 호출 못한다.

			
			  init()------->service()----------->destroy()

			
			method 호출 방식 두 가지
			call: 사용자가 호출  
			invoke: 자동으로 불러옴
			
			
			가) init(): 첫 방문자가 요청시 해당 클래스를 메모리에 로딩시 최초 수행됨 
						단, 한번만 수행된다.			 
						init()메서드가 호출되고 나서 스레드가 start함 
						그 스레드가 Invoker임 
						invoker가 하는일은 service()메서드를 호출 함

			나) service(): 스레드로 처리되는 메서드.
			                   서블릿 엔진은 두번째 사용자의 요청을 받았을때 
					   다시 service() 메소드를 호출하여 
			               서블릿 클래스에 정의 되어 있는 doGet() 또는 doPost() 메소드를 호출한다.
						   즉 여러번 호출 될 수 있음.

			다) destroy():  톰캣(서블릿엔진)을 중지 할때 딱 한번 수행됨.

                  두번째 방문자가 접속하면 (init()이 아닌) service()메서드가 다시 실행됨
		

		

		- 서블릿 작성예 - 교안 그림에 서블릿 프로그래밍, mvc모델 보기@@@

			1)Context Root 안에 서블릿을 위한 디렉토리 생성:예] day1
			2)그 디렉토리 구조를 다음과 같이 구성
				day1+
					+
					+------WEB-INF
							  +---------------classes
							  web.xml

			3)서블릿 소스 코드 작성

				package hello.world;

				import java.io.*;
				import javax.servlet.*;
				import javax.servlet.http.*;     //servlet-api.jar파일에 존재하는 패키지들
				public class HelloWorld extends HttpServlet{

					//오버라이딩
					public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{

						//charset 설정- 한글깨지는 거 방지	
						res.setContentType("text/html;charset=UTF-8");

						//웹브라우저에 보낼 내용을 출력할 문자 스트림(PrintWriter)을 할당 받음(텍스트등을 출력할때)
						PrintWriter writer = response.getWriter();
						



						writer.println("<html>");
						writer.println("<head><title>Hello World</title></head>");
						writer.println("<body>");
						writer.println("<h2>Hello World</h2>");
						writer.println("</body>");
						writer.println("</html>");
						writer..close();

					}

				}

			4)소스코드를 컴파일한뒤 생성된 클래스 파일을 classes디렉토리에 복사한다
			  서블릿 컴파일시 -d옵션을 이용해서 WEB-INF/classes디렉토리로 클래스 파일을 위치하도록 컴파일

				예] src>javac -d ../classes HelloWorld.java 
			5)web.xml파일에서 서블릿 매핑을 한다.

				예]
				<?xml version="1.0" encoding="UTF-8"?>

				<web-app xmlns="http://java.sun.com/xml/ns/javaee"
				   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
				   version="2.5">

					<servlet>	

						<servlet-name>HelloWorld</servlet-name><!--HelloWorld클래스를 HelloWorld라는 서블릿 이름으로 등록한다--->
						<servlet-class>hello.world.HelloWorld</servlet-class>
					</servlet>

					<servlet-mapping>
						<servlet-name>HelloWorld</servlet-name>
						<url-pattern>/Hello</url-pattern>        <!-- url창에서 컨텍스트/Hello라고 첬을때 HelloWorld라는 서블릿이 처리 되도록 매핑-->
					</servlet-mapping>

					<welcome-file-list>		
						<welcome-file>default.do</welcome-file>	<!-- 옵션 사항:Context Root의 시작문서를 default.do로 설정한 것임-->		
				    </welcome-file-list>

				</web-app>

				6)톰캣 시작후 웹브라우저에서 매핑한 정보로 테스트해 본다.



				[서블릿 프로그래밍 절차-MVC방식]

				STEP1] 서블릿 작성

				- 모든 사용자의 요청을 서블릿이 받는다(JSP가 아니라)
				  왜냐하면 서블릿이 컨트롤러 이기때문에

			        - 서블릿코드에서 구현할 내용

					1. 사용자가 전달한 값이 있으면 REQUEST객체의 get()로 받는다
					2. 요청분석해서 model(비지니스 로직)을 호출
					    예] SimpleBoardDAO dao = new SimpleBoardDAO();
					    만약에 모델에서 반환값이 있으면 그 값을 컨트롤러에서 받는다.
						 List<SimpleBoardDTO> dto=dao.getSelectAll();
				    3. 모델에서 받은 값을 request 나 session영역에 저장한다.
					    
					    예]
					    req.setAttribute("속성명",dto);

					4. view선택후 페이지 이동

						RequestDispatcher 객체를 request객체의
						getRequestDispatcher()메서드로 얻어서 forward시키거나(Request영역 공유)

						혹은 response객체의 sendRedirect()메서드로 이동시킨다(request영역 공유 안함

						주의: forward 시킬때에는 컨텍스트 루트를 제외한 경로를 지정하고
						        redirect시킬때에는 컨텍스트 루트를 포함함 경로를 지정한다.

					        예]
						forward:

						RequestDispatcher dis = 
						req.getRequestDispatcher("/MvcSimpleBoard/List.jsp");
						dis.forward(req,resp);

						Redirect:

						resp.sendRedirect(req.getContextPath()+"/MvcSimpleBoard/List.jsp");

					STEP2] 사용자 요청을 서블릿이 받을 수 잇도록 WEB.XML에 서블릿을 매핑

						-<servlet-name> 엘리먼트에 지정한 서블릿명은 임의로 지정하되 web.xml안에서
						   유일해야한다. 즉 중복되서는 안된다.

						 -<url-pattern>에 지정한 형식의 요청이 있는 경우 서블릿명과 일치하는
						   서블릿 클래스에게 사용자의 요청을 전달한다.
						
						<!-- MVCList라는 이름으로 서블릿 등록 -->
						<servlet>
  							<servlet-name>MVCList</servlet-name>
  							<!-- 패키지를 포함한 클래스의 전체 경로 -->
  							<servlet-class>simple.controller.ListController</servlet-class>
						</servlet>

						<servlet-mapping>
  							<servlet-name>MVCList</servlet-name>
  							<!-- 요청 패턴에 해당하는 URL,단 컨텍스트 루트를 제외한 / 부터 작성 -->
  							<url-pattern>/MvcSimpleBoard/List.green</url-pattern>
						</servlet-mapping>

					STEP3] JSP에서 요청시
						- 컨텍스트 루트 경로를 포함한 url패턴을 지정
					<a href="<%=request.getContextPath()%>/MvcSimpleBoard/List.green">
					목록</a>


				[서블릿 프로그래밍 요약]

				STEP1] 요청명으로 링크를 생성한다
					 예] <a href="컨텍스트루트/디렉토리리 경로/요청명">:GET방식
					      <form action="컨텍스트루트/디렉토리리 경로/요청명" method="post">:POST방식

				STEP2]web.xml에 요청명과 서블릿을 매핑한다
					예]

					 <servlet>
						<servlet-name>서블릿명(내마음대로)</servlet-name>
						<servlet-class>패키지를 포함한 클래스경로</servlet-class>
					  </servlet>					  
					  <!-- 등록된 서블릿을 url패턴으로 매핑 -->
					  <servlet-mapping>
						<servlet-name>서블릿명(내마음대로)</servlet-name>
						<!--컨텍스트 루트 제외--->
						<url-pattern>/디렉토리리 경로/요청명</url-pattern>
					  </servlet-mapping>
				STEP3] 서블릿 작성
				           -사용자 요청받고 분석하고 Model의 비지니스로직 호출하고
					    그 결과를 request나 session영역에 저장
					    view(jsp페이지)선택후 redirect나 forward시킨다.
					    redirect시에는 경로에 반드시 컨텍스트루트를 붙인다
					    forward시에는 생략
					    예]
					    -redirect(리퀘스트 영역 공유 안함)
					    resp.sendRedirect(req.getContextPath()+"/디렉토리/jsp페이지");
					    -forward(리쿼스트 영역 공유)
					    RequestDispatcher rd= req.getRequestDispatcher("/디렉토리/jsp페이지");
					    rd.forward(req,resp);
				STEP4] VIEW(JSP페이지)작성후 JSTL과 EL로 request나session영역에
				           저장된 값 출력
					

[JSP(Java Server Page)]  S-S SL이다.

			C-S SL                 S-S SL
			
			JAVASCRIPT             JSP(자바기반)
			HTML,XHTML             ASP(비베),ASPX(C#)
			CSS                    PHP(C)
			JQUERY등등
			
			
			JSP서비스]
			톰캣(무료)          JSP + SERVLET(웹컨테이너)
			WEBLOGIC            WAS(WEB APPLICATION SERVICE)
			JBOSS
			WEBSPHERE
			
			
			ASP,ASPX서비스]
			IIS(INTERNET INFOMATION SERVICE)
			
			PHP서비스]
			아파치

	- JSP 는 웹 상에서 동적인 어플리케이션을 개발하는 방법중의 하나이다
	- JSP는 사용자로부터 호출 될 때 자동으로 servlet으로 변환된다.
	- JSP는 내부적으로 서블릿에서 Exception보다 한단계 위 클래스인 Throwable클래스를
	  try ~catch하기때문에 서블릿처럼 에외처를 안해주어도 됨.기본적인 예외는 처리됨
	- 적은 Programming code를 갖고 동적인 웹 페이지를 생성 할 수 있다.
	- 자바 코드와 HTML 코드를 적절히 조합하여 사용이 가능하다
	- 서블릿보다 쉽고, 빠르다.
	- 디자인 부분과 로직 부분을 분리시킬 수 있다.
	- 프로그래머가 직접 코딩한 Servlet보다 최적화된 Servlet을 생성시켜 
	  효율적인 코드가 만들어진다.
	- JSP는 확장된 컴포넌트를 사용 할 수 있음(Java Beans,Custom Tag 라이브러리)

	* JSP가 서블릿 코드(자바코드)로 변환된 코드는
	Tomcat 버전->work->Catalina->localhost폴더 아래에 존재한다.
	
	* 이클립스로 작업시에는 workspace아래
	.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work아래에 서 찾으면 됨
	
	
	


	JSP의 처리 과정]

		

                                        JSP요청(1)    (Tomcat)        JSP와 관련된 서블릿클래스가 없는경우
			Web Browser   ------------->JSP 컨테이너 --------------->JSP페이지
				                     ▲     |                          |
						처리 |     |서블릿에               |JSP로부터 자바코드 생성
                                                결과 |     |요청전달               |
                                                전송 |	     |		                |		 																								▼
						      |     ▼			       ▼																			  DB 서버

						     서블릿   <---------------- 자바소스코드
							
                                                                    컴파일



	JSP의 구성 요소]


		1)지시어(Directive)

			- 형태는 <%@지시어%> 이다
			
			종류:

				가) page 지시어: JSP엔진에게 JSP파일에 대한 정보를 알려주는 역할 
					
						page 지시어의 속성들

						   -contentType : MIME 타입을 명시. 
						                        text/html,text/plain,text/xml등 image/jpg
									예] contentType="text/html;charset=UTF-8"
								        charset=UTF-8:
									응답과 관련된 문자의 인코딩 셋
									(HttpServletResponse개체의
								        setContentType("text/html;charset=UTF-8");효과와 같다
						   
						   -import : java의 라이브러리를 import 시. 중복 사용이 가능한 속성
									예]
									<%@ page import = "java.util.*, java.sql.*"%>
									<%@ page import = "java.io.*"%>


						   -info   : jsp파일에 대한 설명.예] info= "page지시어에 대한 데모파일"
						  
						   -language :사용하고 있는 언어.예] language="java"
						   -session : 세션의 사용여부 지정. 예] "true"(기본값)| "false"									

						   -buffer :  버퍼의 사용 여부 지정. "8kb"(기본값)| "none"
									  none으로 지정시 jsp가 출력하는 내용을 
									  버퍼에 보내지 않고 
									  바로 웹브라우저로 전송하기때문에
									  <jsp:forward>기능을 사용할 수 없다.
						   -autoflush: JSP 페이지의 내용들이 브라우저에 출력되기 전에 버퍼가 
						                   다 찼을 경우 자동 flush지정
						               예] "true"(기본값)| "false"
									   false:버퍼가 다 찼을 경우 예외를 발생시키고 작업을 중지
						   -errorPage: 에러발생시 보여줄 페이지 지정. 예] "/error.jsp"
						   -isErrorPage: 현재 JSP 가 에러처리를 담당하는 페이지인가를 구분하는 속성
								     예] "false"(기본값)| "true"
						   -pageEncoding: JSP 페이지에서 사용하는 문자의 
						                             encoding을 지정할 때 사용
						                  contentType의 charset의 설정과 동일하게 설정한다.
								  *요청과 관련된 문자의 인코딩 셋
								   HttpServletRequest개체의 setCharacterEncoding("UTF-8")효과와 같다
										<%@ page pageEncoding="UTF-8" %>
										<%@ page contentType="text/html;charset=UTF-8" %>
										혹은
										<%@ page  contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%>						   
						


						   에러 페이지 관련 예]
								- Operator.jsp]

									<%@ page  contentType="text/html; charset=UTF-8" errorPage="error.jsp"%>

									<html>
									<head>
										<title>Operator.jsp</title>
									</head>
									<body>
									<%
										int num1 =10;
										int num2 =0;
									%>
									<h2>num1과 num2의 사칙연산</h2>
									num1 + num2 = <%= num1 + num2 %><p>
									num1 - num2 = <%= num1 - num2 %><p>
									num1 * num2 = <%= num1 * num2 %><p>
									num1 / num2 = <%= num1 / num2 %><p>
									</body>
									</html>

								-error.jsp]

									<%@ page contentType="text/html; charset=UTF-8" isErrorPage="true" %>									
									<html>
									<head>									
									<title>Error Page</title>
									</head>
									<body>
									<h2>다음과 같은 예외가 발생 하였습니다.</h2>
										<%=exception.getMessage()%>
										<!--exception기본 개체는 에러페이지에서만 사용가능한 개체-->
										<!-- IE는 다음과 같은경우에 서버에서 전송한  응답화면이 아닌  
										           자체 제공 오류메시지 화면을 보여줌-->
										<!--
										    응답상태코드가 404나500과 같은 에러코드이고 전체 
										    응답 결과 데이타의 길이가 513보다 작을때
										    또한 지시어 사용없이 web.xml에 설정을 통해 상태코드나 에외타입에 따라 에러페이지를
										    지정할수 잇다.
										-->
									
										
									</body>
									</html>



			  
			  나) include 지시어 : 페이지를 삽일 할때 사용.

			  			   -file : 해당 페이지의 소스가 그대로 삽입 됨.
						           예] "include.jsp" 
						   - 모든 jsp페이지에서 공유하는 변수 선언시나 메소드 정의시 사용
						   - HTML결과가 포함되는게 아니라 소스자체가 그대로 포함도이어짐
                                                     포함된 소스도 함께 자바코드로 변환됨 
						   - file속성에는 상대경로나 혹은 Context 루트를 제외한
                	                              /로 시작하는 절대경로 지정                
						   -지시어 안에는 JSP코드(스크립팅 원소) 사용불가

						     예]  file="/Template/Left.jsp" 혹은  file="../Template/Left.jsp"

						<%@ include file="포함할 파일 경로" %>
				
			  다) taglib : EL(Expression Language), JSTL(JSP Standard Tag Library), Custom Tag를 JSP 페이지내에 사용할때 사용한다.

						
						   -uri : "http://java.sun.com/jsp/jstl/core"
						   -prefix: "c"

						   예]
						   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
							<c:set var="Num" value="100" %>


		 2) 스크립팅 원소(Scripting Element)

			   -기능: jsp페이지에서 자바 코드를 직접 작성할 수 있게 하는 기능

			   
			   -종류:

					가) 선언(declaration)부
						
							- 형태는 <%!자바코드%>
							- 멤버변수의 선언 
							   또는 멤버 메서드를 선언하는 용도로 사용한다.
							- _jspService() 메소드 외부에 선언된다.

							예]

							<%@ page contentType="text/html;charset=UTF-8"%>

							<h1>Declaration Example2</h1>
							<%!
							  int var1;
							  int var2 = 1;

							  public int plusMethod(){
							   return var1 + var2;
							  }

							  String msg;
							  int var3;
							  
							%>

							var1 과 var2의 합은 ? <%=plusMethod()%><br/>
							변수 msg의 값은 ? <%=msg%><br/>
							변수 var3의 값은 ? <%=var3%>



								
					나)	스크립트렛(scriptlet)

							- 형태는 <%자바코드%>
							- 사용자의 요청에 따른 실행가능한 자바 코드를 작성.
							- _jspService() 메소드내에 삽입된다.
							- 이 안에서는 메소드를 구성할 수 없다
							- html 및 자바스크립트 코드 및 css코드안에도 사용가능


어디 들어가는지 확인
D:\LDK\Workspace\.metadata\.plugins\
org.eclipse.wst.server.core\tmp0\work\
Catalina\localhost\JSPProj\org\apache\jsp\Scripting02

					다) 표현식(expression)
					
							- 형태는 <%=자바코드%>
							- _jspService method 내의 자바 코드로 변환된다
							- 문장의 끝에 세미콜론(;)을 붙이지 않는다
							- 결과를 화면에 출력한다.
							- 단순 표현식 외에 데이터의 연산이나 함수를 호출하는 것도 가능하다
							- html 및 자바스크립트 코드 및 css코드안에도 사용가능

				

	JSP의 주석]
	
	HTML(XML) 주석:<!-- 주석 -->
	JSP 주석:<%-- 주석 --%>
	Java Code 주석:<% // 한줄 주석 %>,<% /*여러줄 주석*/ %>



	JSP 내장 개체]

		-JSP 컨테이너가 자동으로 제공하는 객체로 9가지의 기본개체가 있다.

		-----------------+-------------------------------------------------+-------------------------------
		기본개체			 |	 타입					 						   |   설 명
		-----------------+-------------------------------------------------+------------------------------
		request          |       javax.servlet.http.HttpServletRequest     |    클라이언트의 요청 정보 저장
		-----------------+-------------------------------------------------+------------------------------
		response         |       javax.servlet.http.HttpServletResponse    |    응답정보 저장
		-----------------+-------------------------------------------------+-----------------------------------------
		out		         |		 javax.servlet.jsp.JspWriter               |    웹브라우저에 출력을 위한 출력 스트림
		-----------------+-------------------------------------------------+----------------------------------------
		session          |       javax.servlet.http.HttpSession            |    세션 정보를 저장
		-----------------+-------------------------------------------------+------------------------------------
		application      |       javax.servlet.ServletContext              |    웹 어플리케이션에  대한 정보 저장
		-----------------+-------------------------------------------------+------------------------------------------
		pageContext      |       javax.servlet.jsp.PageContext             |     jsp페이지에 대한 정보 저장
		-----------------+-------------------------------------------------+-----------------------------------------
		page             |       java.lang.Object                          |     JSP 페이지 자체를 나타내는 객체 ,
		                                                                              page 객체는 this reference로 page 객체를 참조 할 수 있음
		-----------------+-------------------------------------------------+---------------------------------------------
		config           |       javax.servlet.ServletConfig               |     하나의 서블릿에 대한 정보 저장
		-----------------+-------------------------------------------------+-------------------------------------------
		exception        |       java.lang.Throwable                       |     예외개체.에러 페이지에서만  사용가능
		-----------------+-------------------------------------------------+-------------------------------------------------
		
		*ServletContext(Context 즉 웹사이트 전체 영역에 대한 정보를 
		                       인터페이스로 구현해 놓은 것) 는 웹 어플리케이션 하나당 하나
		 ServletConfig(웹 어플리케이션을 구성하는 서블릿에 대한 정보를
		                     인터페이스로 구현해 놓은 것) 는 Servlet하나당 하나
		
		SevletContext는 ServletConfig로부터 상속 받았다.


		 ServletContext는 jsp에서 Application내장 개체와 같다
		 ServletConfig는 jsp에서 config 내장 개체와 같다.

		1) request 개체

			- 가장 많이 사용되는 개체로 웹브라우저의 요청과 관련이 잇는 개체.
			  즉 클라이언트가 전송한 요청 정보를 제공하는 개체
			
			- request개체가 제공하는 기능 :
				가)클라이언트와 관련된 정보
				나)서버와 관련된 정보
				다)클라이언트가 전송한 요청 파라미터 및 헤더정보
				라)클라이언트가 전송한 쿠키정보등

			- 주요 메서드

				가)클라이언트와 서버의 환경정보에 관련된 메서드
					String getMethod():요청방식(GET, POST, PUT)방식
					String getRequestURL():요청한 URL을 return(전체 URL )
					String getRequestURI():요청한 URI를 return(도메인 부분을 제외)
					String getProtocol():요청에 사용된 프로토콜을 return
					String getServerName():요청을 받은 서버의 이름을 return(도메인명)
					int getServerPort():서버의 포트번호를 return
					String getRemoteAddr():사용자 컴퓨터의 IP Address를 return
					                                             WIN7인경우 url에 localhost루프백 주소 사용시
										     IPV6주소 리턴 . 127.0.0.1이나 혹은 아이피 주소로 테스트
					HttpSession getSession():
					request와 연관된 session개체를 반환 없으면 
					새롭게 생성
					*서브릿에서는 request개체의 getSession으로
					HttpSession개체를 얻어옴 하지만 jsp에서는
					session이라는 기본 내장개체를 제공하기때문에
					사용할 일은 거의 없음(선언부에서는 <%! %>기본 내장 개체 사용못함)
					String getContextPath(): 웹 어플리케이션의 컨텍스트의 경로 return 
					*html에서 절대경로 이용시 getContextPath()사용

				나)클라이언트에서 보낸 파라미터 와 값에 관련된 메서드
					String getParameter(String name):이름이 name인 파라미터의 값 반환,
					                                 존재하지 않을 경우 null return
					String[] getParameterValues(String name):
					이름이 name인 모든 파라미터의 값을 
					배열로 반환 ,

					존재하지 않을 경우 null return

					Enumeration getParameterNames():

					웹 브라우저가 전송한 파라미터의 이름
						예]
							Enumeration paramNames = request.getParameterNames();
							while(paramNames.hasMoreElements()){
							
									String name= (String)paramNames.nextElement();

							}

				다)HTTP헤더와 관련된 정보

					String getHeader(String name):name에 해당하는 헤더의 값을 return
					Enumeration getHeaderNames();모든 헤더의 이름을 return

						예]

							Enumeration headernames = request.getHeaderNames();

							while(headernames.hasMoreElements()){

								String name = (String)headernames.nextElement();
								String value= request.getHeader(name);
								out.println(name+":"+value);
							}
			
				

		2) response개체
			
			- request개체와 함께 많이 사용되는 개체로 웹브라우저에 보내는 
			  응답정보를 담고 있는 개체
			- response개체의 주요 기능은 
			  응답헤더에 헤더 정보를 기록하거나 
			  페이지 이동이다.

			- 주요 메서드

				가)응답 Content 설정에 필요한 메소드
				
					setContentType(String type) :응답 컨텐트의 MIME 타입과 문자 encoding 을 설정.
					                                                       JSP에서는 PAGE지시어에 Content-Type이라는
											       속성에 설정 되어 있음.
											       서블릿에서 현재 웹브라우저에 바로 출력시에
											       사용

				나) 응답 헤더 설정을 위한 메소드

					addCookie(Cookie cookie):Cookie cookie를 응답에 추가.

					boolean containsHeader(String name):
					String name을 이름으로 가지는 응답 헤더가 있는지 boolean 형으로 반환.
					기본 헤더인 Content-Type 및 Content-Length등의 존재 여부 판단시
					단,Content-Length는 body태그 이후에서 판단 해야함.왜냐하면 헤더가 먼저 쓰이고
					응답바디가 쓰임으로.....

					setHeader(String name, String value):
					String name을 이름으로 가지는 헤더에 String value를 저장함.
					setIntHeader(String name, int value):String name을 이름으로 가지는 헤더에 int value를 저장함.
					setDateHeader(String name, long date):String name을 이름으로 가지는 헤더에 long 형의 date를 저장함.
					                                      date값은 1970년 1월 1일 이후로 흐러온 시간을 1/1000초 단위로 지정
								
										
					addHeader(String name, String value):
					String name을 이름으로 가지는 헤더에 
					String value를 추가하여 저장.
					addIntHeader(String name, int value):	
					String name을 이름으로 가지는 헤더에 int value를 추가하여 저장.
					addDateHeader(String name, long date):
					String name을 이름으로 가지는 헤더에 long 형의 date를 추가하여 저장함


					*ADD계열은 기존 헤더값을 변경하고자할때
					 SET계열은 새롭게 헤더를 추가하고자 할때


				다)페이지 이동을 위한 메서드

					sendRedirect(String page):이동할 페이지 경로를 넣어 준다.
					절대경로지정시 컨텍스트 루트를 포함한 경로

 
		3) out개체

			- JSP 페이지가 생성한  결과를 
			  웹 브라우저에 전송해 주는 출력 스트림을 나타낸다
			- JSP 페이지가 웹브라우저에 보내는 모든 정보는 out 객체를 통해 전달이 된다

			- 주요 메서드

				가)출력에 관한 메서드
					
					print(): 데이터 출력
					println():\n과 함께 데이터 출력
					newLine():\n출력


				나)버퍼에 관한 메서드

					boolean isAutoFlush():출력 버퍼가 완전히 찼을 때 자동으로 flush 되면
					                      true를 반환,예외가 발생하면 false를 반환 
					int getBufferSize():출력 버퍼의 size를 int byte 로 반환.
					int getRemaining():	출력 버퍼에서 사용되고 남은 부분의 size를 
					                          int byte로 반환.
					clearBuffer():출력 버퍼에 담긴 내용을 모두 버리고 비움.
					clear() :출력 버퍼를 비우고 그전에 버퍼가 출력되었으면 IOException 발생시킴.
					flush():출력 버퍼와 출력 스트림을 flush 시킴

					예]
							out.println("Hello");
							out.flush();
							out.println("World");
							out.clearBuffer();
							out.println("Hi");

		4)pageContext 개체

			- 해당 jsp페이지의 기본 내장 개체를 얻어 올 수 있는 개체
			- 내장 객체의 속성을 얻을 수 있음.
			- 페이지간의 제어를 할 수 있는 객체 


			- 주요 메서드

				ServeltRequest getRequest(): 페이지 요청 정보를 갖고 있는 
				request 내부객체를 return
				ServeltResponse getResponse():페이지 요청에 대한 
				응답정보를 갖고 있는 response 객체를 return
				JspWriter getOut():	페이지 요청에 대한 응답 출력 스트림인 
				out 객체를 return
				HttpSession getSession():요청한 클라이언트의 세션 정보를 담고 있는
							HttpSession 객체를 return
				ServletContext getServletContext():페이지에 대한 
				서블릿 실행 환경정보를 담고 있는 application 내부 객체를 return
				Object getPage():page 내부 객체를 return
				ServletConfig getServletConfig():페이지의 서블릿 초기 
				  설정정보를 담고 있는 config 내부 객체를 return
				Exception getException():페이지 실행중에 발생되는 
				에러페이지에 대한 예외정보를 갖고 있는 Exception 내부객체를 return


		5]application 개체

			- 웹 어플리케이션당 1개의 개체가 생성되며,
			  웹 어플리케이션에 포함된 모든 JSP페이지는 하나의 application개체를 공유함
			- 웹 어플리케이션 전반에 걸쳐서 사용되는 정보를 담고 있음.
			- 서보 정보등을 읽어 올 수도 잇다.

			- 주요 메서드
				
				가) 컨텍스트 초기화 파라미터를 읽어 올수 있는 메서드

					 String getInitParameter(String name):
					 name이라는 이름의 웹 어플리케이션의 초기화 파라미터 값을 읽어 온다.
					 Enumeration getInitParameterNames():
					 초기화 파라미터의 이름 목록 return


					 *초기화 파라미터는 WEB-INF/web.xml에서 <context-param>엘리먼트를 사용하여 설정한다

					 예]
						<context-param>
							<description>사이트 도메인</description>
							<param-name>MyDomain</param-name>
							<param-value>www.mydomain.com</param-value>
						</context-param>

				나) 서버 정보를 읽어 오는 메서드


					String getSeverInfo():서버의 정보 리턴(예]Apache Tomcat/6.xx)
					String getMajorVersion():서블릿 규약의 버전 정보 중 정수 부분 리턴
					String getMinorVersion():서블릿 규약의 버전 정보 중 소수 부분 리턴


				다)서버의 물리적 경로를 얻어 오는 메서드
					
					String getRealPath(String path): 
					        지정한 경로를 웹 어플리케이션 시스템상의 
						절대 경로로 변경하여 return
					       *Servl
					       etContext의 메서드
					       -파일 다운로드 업로드시 혹은 IO작업시
					       -Context root경로를 제외한 경로명

					InputStream getResourceAsStream(String path):
						절대경로 없이 웹상의 경로를 가지고
						서버에 있는 자원(이미지,텍스트파일..등등)에 대한
						입력 스트림을 반환
						지정한 경로에 해당하는 자원으로부터 데이터를 읽어 올 수 있는
					        InputStream을 리턴



		6] excetion 개체


			- JSP 페이지에서 발생한 예외를 처리할 페이지를 지정한 경우 예외 페이지에 전달되는 객체
			- exception 객체는 isErrorPage="true" 로 지정한 페이지에서만 사용 가능한 내부객체
			- java.lang.Throwable 클래스 타입

				
			- 주요 메서드

				String getMessage():발생된 예외의 메시지를 return
				String printStackTrace(): 발생된 예외를 역추적하기 위해 표준 예외 스트림을 출력함.



			*web.xml에 <error-page>엘리먼트를 설정해서 에러를 처리할 수 있다.
			<!-- IE는 다음과 같은경우에 서버에서 전송한  응답화면이 아닌  자체 제공 
			오류메시지 화면을 보여줌-->
				<!--
				응답상태코드가 404나500과 같은 에러코드이고 전체 응답 결과 
				데이타의 길이가 513보다 작을때
				
				-->

			예]
			<error-page>
				<!--  에러코드를 이용한 에러 처리 -->
				<error-code>404</error-code>
				<!-- 컨텍스트 루트를 제외한 절대경로 -->@@@
				<location>/error/error404.jsp</location>  
			  </error-page>
			<error-page>
			<!--  자바의 예외 클리스를 패키지 포함해서 지정 -->
			<exception-type>java.lang.NullPointerException</exception-type>
			<location>/error/errorNullPointer.jsp</location>
		  
			</error-page>


[서블릿 코드 변환시 메서드 매핑]

	----------------+---------------------+-------------------------------------------------------------------
		Servlet     |         JSP         |       Comment
	----------------+---------------------+-----------------------------------------------------------------------
		init()      |      jspInit()      |       오버라이딩(o),  <%!  %>안에서 오버라이딩
    ----------------+---------------------+---------------------------------------------------------------------------
		destroy()   |      jspDestory()   |       오버라이딩(o), <%!  %>안에서 오버라이딩
    ----------------+---------------------+---------------------------------------------------------------------
		service()   |      _jspService()  |       오버라이딩(x), <% %> 스크립트렛 태그안에 작성된 내용이_jspService()메서드로에 구현됨
    ----------------+---------------------+--------------------------------------------------------------------

	*JSP에서 메서드를 선언하거나 오버라이딩 할때는 선언문 이용 <%! %>안에서  
	 오버라이딩 해야함.
	
	*상기 메서드 jspInit(),jspDestory() 안에서 JSP의 내장 개체를 사용 못한다. 
	 왜냐하면 내장개체는 내부적으로 __jspService()메서드에 선언된 지역변수 이기때문에
         즉 out.println()혹은 request,session,response등의 내장 개체 사용불가

	!!!
	내장 개체의 영역]

		Page 영역 :pageContext개체를 가짐
			한번의 클라이언트 요청에 대하여 하나의 JSP 페이지가 호출되며, 
			이때 단 한 개의 page개체만이 대응이 된다.
		Request 영역:reuest개체를 가짐
			클라이언트의 요청에 대해 같은 요청을 공유하는 페이지가 대응된다.
			요청한 jsp페이지가 다른 jsp를 <jsp:include>하거나 <jsp:forward>하는 경우
			이 두 페이지는 같은 요청 범위에 속하게 되어 같은 request 개체를 
			공유하게 된다.
			웹 브라우저가 요청을 할때마다 새로운 request개체가 생성됨.
		session 영역:session개체를 가짐
			같은 웹브라우저 내에서 요청되는 페이지들은 같은 session체들을
			공유하게 됨
		application 영역:application개체를 가짐
			웹 어플리케이션당 1개의 application 개체가 생성됨.
			같은 웹 어플리케이션에서 요청되는 페이지들은 같은 
			application개체를 공유함.

		영역의 크기]
		
		page < request < session < apllication영역 순


		각 영역에 저장된 속성의 소멸시기]

		page영역:page를 벗어 날때
		request영역: 서버에서 요청에 대해 응답이 완료될때
		session영역:session종료시
		application영역: 서버 종료시


	내장 개체의 속성]
		
		-pageContext,
		request,
		session,
		application
		개체의 속성은 
		JSP페이지 사이에서 정보를 주고 받거나 공유하기 위한 목적으로 사용됨.

		- 속성 추가
			
			setAttribute(String name,Object value): 
			name이라는 이름의 속성에 value값 지정,
			값은 기본 자료형을 제외한 모든 클래스 타입 

		- 속성의 값 얻기

			Object getAttribute(String name): name이라는 이름을 가진 속성의 값을 리턴

		- 속성 삭제

			removeAttribute(String name):name이라는 이름의 속성 삭제

		-속성의 이름 목록 구하기

			java.uti.Enumeration getAttributeNames() :속성의 이름 목록을 리턴
			                                pageContext개체는 이 메서드를 제공하지 않는다.


		

[Action Tag]@@@
	
	-태그처럼 이용하면 되고 태그 안에서 <%= %>로 변수처리가능
	-JSP의 표준 태그이다. // 서버에서 자바코드로 실행
	-<jsp:태그명>으로 표현한다.
	-페이지와 페이지사이의 제어 이동이나 자바빈(좁은 의미)등을 사용하는데 이용된다.
	-Action태그의 각 속성값에는 표현식을 이용해 값을 설정 할 수도 잇다.!!!!!!!!!!
	단,지시어에는 불가
	<%@ include file="<%=pageName%>" %>[x]
		-- <%@ include file%> 는 소스코드가 그대로 복사된다. 페이지가 변하지 않음
	
	-소스보기시 서버측(WAS서버)에서 해석되어 액션태그가 보이지 않음


	-Action Tag의 문법
		
		-XML 문법을 따른다.  // 반드시 종료태그가 있어야 한다.!! "/>"
		-반드시 종료태그를 사용해야 함
			예]
			<jsp:include page="example.jsp" flush="false">
				<!-- 주석을 달 수 없다 .주석 달면 에러-->
				<jsp:param name="파라미터명" value="파라미터값">
			</jsp:include>
			혹은 
			<jsp:include page="example.jsp" flush="false"/>
				--<%@ include file%>와 다르게 서블릿으로 변환이 된다. 다른 페이지가 생긴 것!
				--실행이 되고 나서 결과가 들어온다. 단, request객체는 전달된다.
			

	- Action Tag의 종류
	
		1)<jsp:include>
			 <%@  include %> 지시어처럼 사용 
			 
			- 페이지를 모듈화 할 때 사용.			
			- include한 페이지로 임시적으로 제어를 옮겼다가 
			그 실행 결과를 해당 페이지에 포함.
			- 파일을 합치지 않고 컨텐트를 출력할 때 
			  include한 파일의 출력과 기존 파일의 출력을 통합한다.
			- request개체를 공유한다.

			
			-속성
				page: 모듈화할 페이지경로
				flush:  포함할 jsp페이지를 실행하기전에 출력버퍼에
				         현재까지의 내용을 보낼거인지 아닌지의 여부
				         true인 경우 현재까지의 내용은 물론 헤더정보도 
					 웹브라우저에 보내짐으로
				         포함될 jsp페이지이후부터는 더 이상 헤더정보에 쓰는 
					 작업이 있는 경우 못하게 된다.
				       
				       예]
					-include.jsp

				       <jsp:include page="top.jsp" flush="false"/>
					<%
					
					Cookie cookie = new Cookie("memID","choi");
					response.addCookie(cookie);
					
					%>
					*false시에는 응답헤더에 쿠키 추가됨 그러나 true시에는
					응답헤더에 쿠키가 추가 안됨.


				<jsp:include page="포함될페이지경로" />@@@
					page에는 절대경로/상대경로 다 적용되나
					절대경로시에는 컨텍스트 루트 경로 제외(inlcude지시어도 동일)!!!!!
			
			예]
			
				<%
				String content=request.getParameter("name");
				%>
				<jsp:include page="<%=content%>" flush="false"/>

			
			※ include 지시어와 <jsp:include>액션 태그의 차이점			

				- <jsp:include page=""/>는 다른 jsp로 흐름제어를 이동시켜 
				그 결과물을 현재 위치에 포함시키는 방식인 반면,

				- <%@ include file=""%>는 다른 파일의 내용을 현재 위치에 
				  삽입시킨 후에 
				  jsp파일을 자바 파일로 변환하고 컴파일 하는 방식인 것이다.

				


			※ include 지시어와 액션태그의 사용처
			
				include directive는

				
				- 모든 jsp페이지에서 변수를 공유하는 경우 그 공유하는 변수를
				  선언하고자 할때 사용
				
			   <jsp:include>액션 태그는 주로 페이지의 레이아웃을 
			                       모듈화 하고자 할때 사용
					      - 정적인컨텐츠로 이루어진 페이지를 포함할때
			
		 


		
		2)<jsp:forward>
		


			-다른 페이지로 프로그램의 제어를 이동하는 경우에 사용
			-<jsp:forward>를 만나기 전까지 출력을 모두 제거하고 해당하는 
			   페이지로 이동.즉 <jsp:forward> 이전의 웹브라우저에 출력하는
			   jsp코드는 의미 없다.
			-출력버퍼를 사용하지 않은 경우(buffer="none") 이 
			  액션태그를 사용못함 즉 에러발생(JSP규약)
			-request 개체를 공유한다.
			-조건에  따라 여러페이지로 이동해야 할 경우에 사용

			-forward 액션 태그는 아래 자바코드와 같은 액션을 일으킨다
			 <%
				RequestDispatcher rd=request.getRequestDispatcher("포워드시킬 페이지명");
				rd.forward(request,response);
			 %>


			-속성
				page: 이동할 페이지명
				

			예]
				<jsp:forward page="이동할 페이지명"/>
				<jsp:forward page="<%=expression%>" />


			-페이지 이동 차이점

				-<jsp:forward/>:
				                            페이지를 이동시키되,이때 이동된 페이지와 이동시킨 페이지는 
							    request를 공유한다.
							    forward는 클라이언트와 통신없이서버에서만 처리되기 때문에 
							    리다이렉트
							    보다 나은 성능을 보여줌
								-url이 변경 안됨

				-response.sendRedirect():
				         메소드에 지정된 url로 페이지를 이동시킨다.
					 그러나 forward액션과는 달리
					새로운 request를 발생시킨다
					또한 sendRedirect는 새로운 요청을 발생시켜 페이지를 이동 시킨후 이후로도 
					로직을 계속 수행한다
					로직을 수행 못하게 하려면 return;헤야 함
										(
										location개체의 href와 같음)
					-url이 변경됨.



		
		3)<jsp:useBean>
			이제 잘 안 쓴다.
			
			- 자바빈(Java Bean)(좁은 의미의 자바빈) 객체 생성시 사용	
			
			- 자바빈 생성시 생성과 동시에 scope에 지정한 영역에 
			   속성명은 id에서 지정한 이름으로  
			   그리고 속성값은 자바빈 개체를 설정함
			
			- <jsp:useBean>액션 태그는 자바빈 생성시 기존에 개체가 
			                        존재하면 생성하지 않고 
			   기존의 개체를 그대로 사용함
			   (class속성 사용시)
			   그러나 class대신에 type속성을 사용하면 기존에 개체가 존재하고 있다고 
			   가정하기 때문에
			   만약에 개체가 존재하지 않는다면 에러발생


			- scope에 지정한 값에 따라 자바빈 개체가 저장되는 속성을 가진 기본 개체는 아래와 같다

				page:pageContext 내장 개체
				request:request 내장 개체
				session:session 내장 개체
				application: application내장 개체
	
			- 속성
				id : 생성될 자바빈 개체의 이름을 명시 - 인스턴스 변수 역할
				
				class : 자바빈 클래스 명을 명시,
				          클래스의 패키지를 포함한 Full Name을 명시
					  즉 import한 것과 같다.
				         class속성 대신에 
					 type도 가능(자바빈 개체가 존재 한다고 가정-없으면 에러발생함)

				scope : 자바빈의 유효 범위 및 공유 범위 명시
				        page, request, session, application 으로 구분 가능.	
					page 값이 기본값
						

			※MVC프레임워크의 사용과 표현언어(EL)의 사용으로 점차 사용빈도가 줄어듬.
			 
			예]
				<jsp:useBean id="jbd" 
				class="자바빈의 패키지를 포함한 전체 클래스명" 
				scope="request"/>
			

				위코드는 아래의 자바 코드와 같다

				JavaBeansDemo jbd = (JavaBeansDemo)request.getAttribute("jbd");
				//기존에 자바빈 개체 jbd가 없다면
				if(jbd==null){
					
					//자바빈 개체 jbd생성
					jbd=new JavaBeansdemo();
					//request영역에 속성으로 jbd개체를 저장
					request.setAttribute("jbd",jbd);
	

				}

			

			- Java Bean(좁은 의미)이란 
					데이터를 표현하는 것을 목적으로 하는 
					자바 클래스(Data Transfer Object:DTO).
				        자바빈 규약을 따르는  클래스. 
				            
			
			- 자바빈 규약

				
				1) Bean의 멤버 변수(속성,프라퍼티)는 반드시 private로 선언한다. 
				2) Bean의 메소드는 public으로 선언한다.
				3) 속성에 해당하는 setXXX/getXXX 계열의 메서드가 존재 해야 한다.
				4) 사용자정의 메소드 추가 가능하다.

				* form의 하위요소의 이름과 
				 자바빈의 속성(멤버변수)과 이름을 같게 하는게 좋다.

				 MemberDTO member = new MemberDTO();
				 member.setId("kim");
				 member.setPwd("1234");

		4)<jsp:setProperty >

			-Java Bean 객체의 속성을 저장하는 경우
			-자바빈의 setXXX() 함수를 호출

			-속성
				name  : 자바빈 개체의 이름(useBean태그의 id속성에 지정한 값 
				즉 인스턴스 변수를 넣어준다)
				property: 속성명.즉 자바빈의 멤버 변수
						property="*"라고 지정한 경우 form의 하위요소와 일치하는 자바빈의 모든 속성에 사용자가 입력한 값이 설정됨.
						이때는 value속성 생략.
						예]
						<jsp:setProperty name="자바빈" property="*"/>
					
				value : 멤버변수에 설정할 값
				        value대신에 param속성을 사용할 수 있다 param 속성 사용시에는 form의 하위 요소의 이름을 넣어주면
						그 하위요소에 해당하는 값이 설저왼다.
						예]<jsp:setProperty name="자바빈" property="자바빈속성" param="폼하위요소명"/>
			
					     
					



		

		5)<jsp:getProperty>
			-Java Bean 객체의 속성을 읽어 오는 경우
			-자바빈의 getXXX() 함수를 호출

			-속성
				name  :자바빈 개체의 이름
				property: 속성명

		※중요]
		jsp:getProperty 나 jsp:setProperty의 name속성에는
		반드시 jsp:useBean액션 태그의 id속성에 지정한 값이어야 한다
		자바코드로 생성한 인스턴스 변수는 불가.	
				


		6)<jsp:param>

			-<jsp:inlcude>액션태그나 <jsp:forward> 사용시 데이타를 전달하고자 할때 사용
			-String타입의 값만 전달 할 수 있다.			
			-String형이 아닌 다른 자료형을 전달하고자 할때는 
			 param액션태그가 아닌 내장 개체의 속성을 이용한다.

			- 속성
				name:파라미터 명
				value:파라미터명에 해당하는 값
				
				<jsp:param name="파라미터명" value="값"/>



[쿠키(Cookie)]

	- 쿠키란?

		쿠키는 상태정보를 유지하기 위한 기술로 
		클라이언트에 상태정보를 저장한다.

		- 쿠키는 클라이언트의 PC나 웹브라우저에 저장되는 간단한 정보를 의미.
		- 웹서버는 웹브라우저가 전송한 쿠키를 사용해 필요한 데이터를 읽어올 수 있다.

		- 쿠키는 그 크기가 하나에 4KB 이하로 제한이 되어 있으며, 
		  총 300개까지 정보를 저장할 수 있다. 
		  따라서,최대로 저장가능한 쿠키의 용량은 1200KB 즉 1.2MB


		-로그인할때는 안 쓰고 간단한 정보르르 저장할 때 쓴다.
		  로그인할때, 아이디 저장 버튼을 쿠키로 저장한다.
	
		-쇼핑몰 장바구니도 쿠키로 할 수 있다.
		

	- 쿠키의 주요 메서드

		String getName():쿠키의 이름 리턴
		String getValue():쿠키의 값 리턴
		String getPath():쿠키의 적용 경로 리턴 - setPath()로 미 설정시 null
		int getMaxAge():쿠키의 유효시간 설정, - setMaxAge()로 미 설정시 -1
							getMaxAge설정시 브라우저가 아닌 pc에 저장된다.						
		setValue(String value):쿠키의 값 설정 
		setDomain(String domain):쿠키가 적용되는 도메인 설정
		                         서브도메인에도 쿠키를 
					 적용하고자 할때에는 
					 ".도메인"을 넣어준다
					 예]www.naver.com에서 생성한 
					 쿠키를 mail.naver.com에서도 
					 적용하고자 할때
				         setDomain(".naver.com");
		setPath(String path):쿠키가 적용되는 경로지정
				 지정한 경로 또는  하위 경로에만 대해서만 쿠키가 적용된다.
				예]
				setPath("/notice");notice디렉토리와 그 하위 
				             디렉토리에서만 쿠키를 사용할 수 있다
				setPath("/"):웹 어플리케이션 전체 경로에서 사용하고자 할때

							
								
		setMaxAge(int exp):쿠키의 유효시간을 초 단위로 설정. 
                           유효시간을 설정하지 않으면 쿠키정보는 
			   웹브라우저 메모리에 저장되고 
			   웹브라우저를 닫으면  자동으로 삭제된다.
			   유효시간을 설정하는 경우 쿠키정보는 사용자의 pc에 저장된다.
						    


	- 쿠키 설정 절차 및 동작방식

		1) 클라이언트가 처음 서버에 접근하면 서버는 쿠키를 
		   생성하고 http응답 헤더에 쿠키를 실어서 보낸다.
		2)후에 사용자가 그 사이트를 다시 방문하는 경우 
		   웹브라우저는 저장된 쿠키 정보를 서버에 전송한다.
		3)서버는 이 쿠키 정보를 이용해 필요한 작업을 수행한다.

	
	- 쿠키에 값 저장시(로그인 처리)


			1)쿠키 개체 생성 

			
				javax.servlet.http.Cookie cookie =
				new javax.servlet.http.Cookie(String name, String value)


			2)생성한 쿠키를 response개체를 통해 응답헤더에 추가

				response.addCookie(쿠키개체)


			예]

				Cookie cookie = new Cookie("memID","choi");
				response.addCookie(cookie);
			



	- 쿠키에 저장된 값 읽어 오기(로그인 여부 판단)
	
				-request개체의 getCookies()메서드를 이용해서 읽어온다.

				Cookie[] cookies = request.getCookies()
				
			

				예]
				Cookie[] cookies = request.getCookies();

				if(cookies!=null && cookies.length > 0){
				
					for(int i =0;i< cookies.length;i++){


						out.println("쿠키명: "+cookies[i].getName()+",쿠키 값:"+cookies[i].getValue()+"<br/>");

					}

				}
	
				
	- 쿠키 삭제(로그아웃)

			-setMaxAge()메서드의 인자값을 0을 주어서 삭제한다.
			
			Cookie cookie = new Cookie("memID",""); // 빈 문자열로 값을 주기 
			cookie.setMaxAge(0); // 쿠키 유효기간 설정 안 했으면 안 해도 된다.
			response.addCookie(cookie);

	- 쿠키값 변경

		해당 쿠키명으로 다시 Cookie개체를 생성하면 된다. 
		단, 해당 쿠키가 없을때는 새롭게 쿠키가 생성된다
			
			예]
			Cookie[] cookies = request.getCookies();

					if(cookies!=null && cookies.length > 0){
					
						for(int i =0;i< cookies.length;i++){

							if(cookies.getName().equals("memID")){
								
								Cookie cookie = new Cookie("memID","lim");
								response.addCookie(cookie);
							}

						}

					}

		

	- 쿠키의 구성 요소

			 형태 : 웹서버가 웹브라우저에 전달하는 쿠키를 설정할 때
			 Set-COOKIE : name=value ; expire=date ; path=path; domain=domain; secure

			 name: 각 쿠키를 구별하는 데 사용되는 이름
			 value : 쿠키의 이름에 해당하는 값
			 expire : 쿠키 유효 기간.   expire을 기술하지 않으면 현재 웹브라우저가 실행되는 동안만 유효함
			 domain: 쿠키가 적용되는 도메인
			 path: 쿠키가 적용되는 디렉토리 경로

	- 쿠키 이름 및 값에 대한 규칙(RFC2109규약)
		
		:쿠키 이름은 아스키코드 알파벳과 숫자만 포함할 수 있다.
		:콤마(,), 세미콜론(;), 공백('') 등의 문자는 포함할 수 없다.
		:$로 시작할 수 없다.

		따라서 한글등을 쿠키값에 포함하려면 반드시 인코딩 처리를 해줘야 한다.

	   예] 
						  Cookie cookie = 
						  new Cookie(URLEncoder.encode("이름","UTF-8"),URLEncoder.encode("홍길동","UTF-8"));
						  response.addCookie(cookie);

						  out.println(URLDecoder.decode(cookie.getName()));
						  out.println(URLDecoder.decode(cookie.getValue()));
	
[세션(Session)]@@@

	- 세션이란?
	
		클라이언트가 서버에 접속해 있는 상태를 말하는것으로 

		방문자가 웹 브라우저를 열어 서버에 접속하고 다시 웹브라우저를 닫아

		서버와의 연결을 종료하는 하나의 단위를 세션이라 함 즉 
		접속한 상태의 유지기간을 의미함


		- 클라이언트의 상태정보를 저장하기 위한 기술. 
		  내장 개체중 session개체에 정보가 저장됨.
		- 쿠키는 클라이언트에 저장되지만 session은 서버에 저장된다.
		- session 개체는 웹브라우저당 1개의 개체가 할당되어 
		 사용자 인증에 관련된 작업을 수행 시 주로 사용
		- page 지시자의 session 속성이 "true"인 경우에만 사용 가능.(기본값 true)
		- session개체는 일정시간동안 
		  아무런 요청도 하지 않으면 자동적으로 삭제 된다
		  (기본: 30분)
		-세션 설정시 내부적으로 JSESSIONID라는 쿠키명으로 세션아이디값을 
		 쿠키값으로 설정한다.

		- session개체의 주요 메서드

				String getId(): 해당 세션의 세션 ID를 return
				long getCreationTime(): 
				session의 생성된 시간을 1970년 1월1일 이후 흘러온 
				시간을 1/1000초단위로  return
				long getLastAccessedTime():
				웹 브라우저의 요청이 마지막으로 시도된 시간을 
				1970년 1월1일 이후 흘러온 시간을 1/1000초단위로  return
				void setMaxInactiveInterval(time): 
				session을 유지할 시간을 초 단위로 설정
				int getMaxInactiveInterval():세션유지 시간 얻기				
				void invalidate():세션 기본개체가 삭제됨.
				즉 할당된 세션의 속성값을 모두 제거,주로 세션을 종료할 때 사용.
				boolean isNew(): 새로운 클라이언트인지 판단. 
				즉 새로운 세션이면 true ,아니면 false 리턴


		- 세션 유효 시간 설정
				
				가)web.xml에서
					WEB-INF/web.xml에 <session-config>엘리먼트에서 설정(분 단위)
					<session-config>
						<session-timeout>20</session-timeout>
					</session-config>
				나)session개체의 메서드로 설정(초 단위)

					session.setMaxInactiveInterval(60*20);
			
		- 세션개체에 값 저장시(로그인 처리)

				session.setAttribute(String key,Object value)

		- 값 읽어 올때(로그인 여부 판단)
				Object value=session.getAttribute(String key);

		- 세션 개체의 특정 속성  삭제

				session.removeAttribute(속성명);

		-  세션개체에 저장된 모든 속성 삭제시(로그아웃 처리)
				session.invalidate();


		소스예] 모든 세션개체에 저장된 값 읽어 오기

		 Enumeration<String> en=session.getAttributeNames();

		 while(en.hasMoreElements()){
			 
			String key= en.nextElement();
			
			Object val = session.getAttribute(key);
			out.println(key+"==="+val.toString()+"<br/>");
			 
		 }
	





[Expression Language]@@@
		
		
		${}  -> 자바코드로 바뀐다. out.print()... 
		
	
		- 값을 표현하는데 사용되는 스크립트 언어(compile안함)로 
		   JSP의 기본 문법을 보완하는 역할을 함.

		  즉 값을 출력하는데 사용한다.값을 할당하지는 못한다(예:${sum=10} //요즘은 가능!
		- 표현식(<%= %>)을 사용하는 것보다 간단한 방법으로 값을 출력 할 수 있다.
			스크립트 요소안에서 EL사용 불가!
			
		- 자바 코드를 사용해야 하는 모든 곳에서 사용가능

		- 자바스크립트에서 확장하고 
		   Xpath(XML 문서의 정보에 접근하기 위해 사용되는 언어)에서 힌트를 얻어 만들어진 언어
		- null 값을 갖는 변수에 대해 좀더 관대하고, 
		  데이터형 변환을 조금 더 자동으로 해준다

		  즉 값이 존재 하지 않을 경우 에러를 발생시키지 않고 
		    아무값도 출력하지 않은다.(NullPointerException에러 안남)
		- 개체의 값에 접근할때 자바빈(좁은 의미) 개체의 프로퍼티 규칙을 따라 접근한다.
		  
		  예]

			<%
				Member member = new Member();
				member.setName("홍길동");
				
			%>
			<c:set var="mem" value="<%=member%>"/>

			
			 

			${mem.name}  =>는 member.getName()을 호출한 것과 같다.


		  예2 ]	
				-[forward.jsp]

				<%@ page contentType="text/html;charset=UTF-8" %>
				<%@ page import="el.member.*" %>

				<%

					Member m = new Member("홍길동","강남",20);

					int num = 10;
					String str="문자열";

					request.setAttribute("member",m);
					request.setAttribute("num",num);
					request.setAttribute("str",str);



				%>
				
				<jsp:forward page="elEtcDemo.jsp"/>


				-[elEtcDemo.jsp]
				<%@ page contentType="text/html;charset=UTF-8"%>
				<%@ page import="java.util.*,el.member.*" %>

				<h2>forward로 전달된 값 벋기</h2>

				--자바코드로<br/>
				<%
					Member m = (Member)request.getAttribute("member");

					String name1 = m.getName();
					String addr = m.getAddr();
					int age = m.getAge();


					String str = (String)request.getAttribute("str");

					int num  = (Integer)request.getAttribute("num");

				%>
				

				이름:<%=name1%><br/>
				주소:<%=addr%><br/>
				나이:<%=age%><br/>

				문자열:<%=str%><br/>
				수자:<%=num%><br/>

				--EL식으로 <br/>

				이름:${member.name}<br/>  //requestScope생략 가능
				주소:${requestScope.member.addr}<br/>
				나이:${requestScope.member.age}<br/>

				문자열:${str}<br/>
				수자:${requestScope.num}<br/>

				---에러 타스트<br/>
				나이:${member.age1}<br/>  //-->에러
				나이:${member1.age}<br/>  //-->에러 안나고 값이 출력 안됨
				
				문자열:${str2}<br/> //-->에러 안나고 값이 출력 안됨


				*EL에서는 요청 파라미터는 
				 param.파라미터명(=request.getParameter():형변환 필요)
				 Resquest.setAttribute()에 설정한 속성은 
				            ${속성명} 혹은 ${requestScope.속성명}으로
					    (=request.getAttribute():형변환 필요)

	

				※ 각 영역에 저장된 값을 EL로 읽어 올때 속성명이 동일하다면 
				  EL의 내장 객체영역명 생략시 리쿼스트 영역에서 읽어 온다.
				    영역에 저장된 값을 EL로 읽어 올때 영역을 지정하지 않으면
				    작은 영역부터 순차적으로 읽어 온다

				  
				     
				 예]	
					
					------B.jsp----------------------------					


					<%
					request.setCharcaterEncoding("UTF-8");
					application.setAttribute("msg","어플리케이션");
					session.setAttribute("msg","세션");
					request.setAttribute("msg","리쿼스트");
					
					//자바코드로 FORWARD
					

					
					
					%>
					
					-------A.jsp---------------------------
					${msg}   =>"리쿼스트" 문자열이 출력 됨


		표현언어의 기능]

			- JSP의 네가지 기본 개체(requ,pag,sess,appli)가 제공하는 영역의 속성 사용
			- 변수와 연산자를 포함.
			- 자바 클래스 메서드 호출 가능
			- 표현언어만의 개체 제공
	
		표현언어의 구문]
				<% String a="name"; %>
				${a}//불가능 , 자바코드에서 생성한 개체변수에 직접 접근 못한다.
			
				<% String a="name"; %>
				<c:set var="b" value="<%=a%>"/>
				${a 인지 b????}//가능 ,   JSTL을 이용
			
			
			-  ${expresion}
			-  expression는 표현언어가 정의한 문법에 따라 값을 표현하는 식
			   expression에는 자바코드에서 생성한 개체변수에 직접 접근 못한다.
			   JSTL을 이용해야 함.

			-  JSP 스크립트[스크립트릿(<% %>),표현식(<%= %>),
			   선언부(<%! %>)]에서는 사용 불가능	
			-  Action Tag나 JSTL(<c: set  />)등의 속성의 값으로 사용할 수 있다. 
			  <jsp:include page="/${info.type}/info.jsp" />
			-  비 스크립트 요소에도 표현식처럼 값을 출력하기 위해 사용 가능.
			     <b>${sessionScope.memeber.id}</b>
			   즉 JSP 스크립트 요소에서만 사용이 불가하고 
			   거의 모든 태그 요소에서 표현이 가능하다

			   결론:jsp 스크립트 요소 안에서만 사용못하고 
			   모든 태그류(Action Tag,JSTL,HTML)에서는 사용할수 있다.
			
			
				

		표현언어의 내장 개체]
			표현언어의 내장객체는 setter가 없다.

			pageScope: pageContext 기본 개체에 저장된 속성의 <속성,값> 매핑을 저장한 Map Collection
			requestScope:request 기본 개체에 저장된 속성의 <속성,값> 매핑을 저장한 Map Collection
			sessionScope:session 기본 개체에 저장된 속성의 <속성,값> 매핑을 저장한 Map Collection
			applicationScope:application 기본 개체에 저장된 속성의 <속성,값> 매핑을 저장한 Map Collection
			
			값을 얻어올때: XXXXScope.속성명
			
			param:요청 파라미터의 <파라미터명,값> 매핑을 저장한 
			      Map Collection,파라미터값의 타입은 String
			      request.getParameter(파라미터명)와 동일

			 값을 얻어올때:param.파라미터명

			paramValues:요청 파라미터의 <파라미터명,값배열> 매핑을 저장한 Map Collection
						파라미터값의 타입은 String[], request.getParametervalues(파라미터명)와 동일
			
			값을 얻어올때: paramValues.파라미터명

			header:요청정보의 <헤더이름,값> 매필을 저장한 Map Collection
			값을 얻어올때: header.헤더명 단, user-agent의 경우
			                    헤더명에 - (대쉬) 가 들어가기때문에
					    header["user-agent"]로 얻어 옫?
			
			headerValues:요청정보의 <헤더이름,값배열> 매필을 저장한 Map Collection
			             request.getHeaders(이름)결과와 동일

			cookie:<쿠키명,값> 매핑을 저장한 Map Collection.
			
			값 얻어올때: cookie.쿠키명.value

		
			initParam:초기화 파라미터의 <이름,값>매핑르 저장한 Map Collection .
			application.getInitParameter(이름)결과와 동일

			값 얻어올때: initParam.파라미터명(web.xml에 설정한)
			
			
			pageContext:JSP의 pageContext기본 개체와 동일

					  jsp에서 컨텍스트 루트를 얻어 올때 <%=request.getContextPath()%> 이용
					  el에서는 ${pageContext.request.contextPath}
					    즉 request객체 얻어서(getReuest()) getContextPath() 메서드 호출한 것과 같다



		EL의 데이타 타입]

			블리언 타입:true,false
			정수타입:0~9로 이루어진 정수값
			실수타입:0~9로 이루어져 있고,소수점 및 지수 표현 가능
			문자열 타입:' 또는 " 로 표현
			널타입:null
			                                                                                                                                    
			


	
		EL의 연산자]

			1)산술 연산자:+,-,*,/,%,div(/랑같다),mod(%랑 같다)
					
				예] ${"2"+1} =>3  :숫자형식의 문자열은 숫자로 변환됨.
					
					

					${"이"+1} =>에러는 안난다.     +는 숫자에서만 
					${null+1} => 1 :null은 0으로 처리 됨

					${3/2} => 1.5 :double타입으로 변환뒤 연산 수행


				주의] 자바에서 스트링 연결시 +도 가능 했으나 EL에서는
				       +는 숫자 연산에만 적용되는 연산자임.
				       고로 문자열을 +로 연결시에는 에러[X]
				 

			2)비교 연산자:==(eq),!=(ne),<(lt),>(gt),<=(le),>=(ge)

						
					${"hello"=="hEllo"} => 
					자바의 주소비교가 아니라 문자열값 비교:false

					※숫자 비교시 자바의 String클래스의 compareTo()메소드 방식으로
					  비교후 true아니면 false를 반환해 준다
			3)논리연산자: &&(and),||(or),!(not)


			4)empty연산자:개체가 비어 있는지 검사!!!!!!!!!!!!!
				empty<값> :값이 null,빈문자열(""),
				길이아 0인 배열,저장개체가 0인 Collection인 경우 true리턴

			5)삼항 연산자
			    <조건>?<값1>:<값2>  예] ${ 10 >2 ? 10: 2} =>10

			   


				예]
				<%
					ArrayList list = new ArrayList();
				
					list.add("홍길동");
					list.add("강산애");
				%>
				<%=list.get(0)%><br/>

				<c:set var="lt" value="<%=list%>"/>
				${lt[0]} <br/>

				empty: ${not empty lt ? "개체가 있음":"개체가 비었음"}
	

		EL에서 개체의 접근]

			-점(.) 이나 대괄호([])를 사용해서 접근한다.
			[]는 배열에서 값을 꺼내올때 주로사용
			  
		
			예]
			
				${param.name} 이나 ${param["name"]}은 같은 표현이다 => request.getParameter("name")

				${header.host}:${header.host} [o]
				${header["user-agent"]}[o]
				${header.user-agent}[x]

				혹은 개체에 인덱스로 접근시에 []를 사용한다.

				<%
					ArrayList list = new ArrayList();
					list.add("홍갈동");
					list.add("강산애");

					String[] mountain ={"한라산","지리산","설악산"};

				%>
				<c:set var="obj" value="<%=list%>"/>
				<c:set var="mountain" value="<%=mountain%>"/>
				${obj[0]} =>홍길동

				
				${mountain[0]}=>한라산[o]
				${mountain["1"]}=>지리산[o]
				${mountain['2']}=>설악산[o]
				${mountaib.0}=>에러[x]

				
		

		EL에서의 자바 클래스 메소드 호출]	@@@	


			호출을 위한 작성순서]

				1)자바 클래스파일을 작성한다.
					-EL에서 클래스의 메서드를 호출하려면 클래스 정의시 메서드를 
					반드시 public static으로 정의해야 한다.

				2)TLD(Tag Library Descriptor) 파일을 작성한다.

					-커스텀 태그의 동작을 정의하는 XML형식의 파일
					
					-tld파일은 WEB-INF/아래에 바로 놓거나 하위 디랙토리에 두면
					 컨테이너가 자동으로 찾아서 씀.(WEB-INF/tlds디렉토리에 위치)

					-tld파일의 태그 요소에 대한 정의는 아래 JSP 2.1 스펙에서 참조
					http://jcp.org/aboutJava/communityprocess/final/jsr245/index.html

					혹은 jakarta-taglibs-standard-1.1.2\jakarta-taglibs-standard-1.1.2\tld안의
					fn.tld 참조 나
					standard.jar안의 standard\META-INF\안의 fn.tld 참조

					<?xml version="1.0" encoding="UTF-8" ?>
					<taglib xmlns="http://java.sun.com/xml/ns/j2ee"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
						version="2.0">
    
						  <description>My Tag library</description>
						  <tlib-version>1.1</tlib-version>
						  <short-name>my</short-name><!--접두어로 사용할 이름-->
                           
						  <function><!-- EL에서 사용할 함수정의시 사용하는 엘리먼트. 메서드 하나당 한개-->
								<name>myFunc</name> <!---EL에서 사용할 메서드 명--->
								<function-class>클래스 전체 경로(패키지포함)</function-class>
								<function-signature>
									java.lang.String 메서드명(java.lang.String )
									<!-- 메서드 기록.리턴타입과 인자의 타입은 완전한 클래스 이름!!
									인자의 경우 타입만 적는다,
									단 기본자료형인 경우는 기본 자료형만(예: int) -->
								</function-signature>

						  </function>

					</taglib>


					 
					 

				3)web.xml을 작성한다.
					-tld파일에 대한 정보 추가
						<jsp-config>
							<taglib>
								<taglib-uri>	
									/WEB-INF/tlds/tld파일명 
									<!-- JSP의 taglib지시어의 uri속성에 넣어 줄 값-->
								</taglib-uri>
								<taglib-location>	
									/WEB-INF/tlds/tld파일명 <!-- tld파일의 위치-->
								</taglib-location>	

							</taglib>
						</jsp-config>

				4)자바 메소드에 접근하는 JSP 파일을 작성한다

					<%@ taglib prefix="my" uri="/WEB-INF/tlds/tld파일명" %>


					${태그라이브러리접두어:메서드명(인자1[,인자2,..])}
					-메서드명은 tld파일에서 정의한 
					<function-name>엘리먼트의 텍스트

				
				

	
[JSTL(JSP Standard Tag Library)]@@@

	- 표준화 된 custom Tag 이다.
	- 많이 사용되는 사용자 정의 태그를 모아서 JSTL이라는 규약을 만듬.
	- JSP내에 Java Source 를 사용하지 않고, 태그만을 가지고 작성하도록 한다
	  그래서 가독성을 증가시킴
	- 스크립틀릿, 표현식을 사용하는 것보다 훨씬 간결한 문법 구조를 지원.
	- JSP 2.1(톰캣 6버전) 과 호환되는JSTL버전은 1.2이다.
    -  JSTL은 5가지의 태그를 지원한다.

	※<script> </script>태그 안에서 작성시 인텔리센스가 안됨 즉 CTRL+SPACE바 클릭시
	속성등이 뜨지 않음 .직접 코딩해야함


	----------------+------------------------------------+-------------------+---------------------------------------------
                         라이브러리    |             기능                                             |     접두어                     |            관련 URL
    ----------------+------------------------------------+-------------------+---------------------------------------------
          Core      |   변수지원, 흐름 제어, URL 처리                        |       c           |    http://java.sun.com/jsp/jstl/core 
	----------------+------------------------------------+-------------------+----------------------------------------------
          XML       |   XML 코어, 흐름 제어, XML 변환                     |       x           |    http://java.sun.com/jsp/jstl/xml
	----------------+------------------------------------+-------------------+--------------------------------------------
                     국제화              |   지역, 메시지 형식, 숫자 및 날짜 형식                  |       fmt         |    http://java.sun.com/jsp/jstl/fmt
	----------------+------------------------------------+-------------------+-----------------------------------------------
                  데이터베이스        |   SQL                              |       sql         |     http://java.sun.com/jsp/jstl/sql
	----------------+------------------------------------+-------------------+----------------------------------------------
                       함수               |   콜렉션 처리, String 처리                               |       fn          |    http://java.sun.com/jsp/jstl/functions
	----------------+------------------------------------+-------------------+-----------------------------------------------



	환경설정]

		1) http://jstl.java.net/접속->downloads jstl->에서 jstl-api-1.2.jar와 jstl-impl-1.2.jar
             혹은
            http://www.apache.org/->하단 project에서 Tomcat->좌측의 taglib클릭->Apache Standard Taglib클릭-> Standard 1.1다운
        
        를 다운 받는다
		2)다운 받은 jar파일을 해당 프로젝트의 WEB-INF/lib폴더에 복사한다. 

		혹은 
		이거 사용@@@
		http://tomcat.apache.org/taglibs/standard/-> Servlet 2.4, JavaServer Pages 2.0 downloads-> binaries/->
		jakarta-taglibs-standard-1.1.2.zip 다운후 압축을 풀어 jstl.jar와 standard.jar를 WEB-INF/lib폴더에 복사


	
	JSP에서의 사용법]

		- taglib 지시어를 사용하여 JSTL의 태그 라이브러리에 접근한다.

		  <%@ taglib prefix="접두어" uri="각 태그의 관련 URL주소" %>

		  사용시에는 <접두어:태그명 />식으로 사용



	Core Tag의 주요 기능]

		-표현언어(Expression Language) 지원 기능
			<c:catch>, <c:out>, <c:remove>, <c:set>
		-흐름제어 기능
			<c:choose>, <c:when>, <c:otherwise>, <c:forEach>, <c:forToken>, <c:if>
		-URL 관리 기능
			<c:import>, <c:param>, <c:redirect>, <c:url>
		- 사용법

			<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>


	Core Tag의 종류]
		
		------------+----------------+------------------------------------------------
		기능             |     태그명           |          기능설명
		------------+----------------+-----------------------------------------------
		변수 지원     |      set                |      EL에서 사용될 변수를 설정합니다.
			    |         remove         |      설정한 변수를 제거합니다.
		------------+----------------+-----------------------------------------------
		흐름 제어      |      if             |      조건에 따라 내부 코드를 수행합니다.else문이 없다
			     |      choose        |      다중 조건을 처리할 때 사용됩니다.
			     |      forEach        |      Collection의 각 항목을 처리할 때 사용합니다.
			     |      forTokens    |      구분자로 분리된 각각의 토큰을 처리할 때 사용합니다. 
		------------+----------------+-----------------------------------------------
		URL 처리      |      import          |      URL을 사용하여 다른 자원의 결과를 삽입합니다.
			     |      redirect        |      지정한 경로로 이동합니다.
			     |      url                |      URL을 재 작성합니다. 
		------------|----------------+-----------------------------------------------
		기타 태그      |      catch            |     예외 처리에 사용합니다.
			     |      out               |    jspWriter에 내용을 알맞게 처리한 후 출력합니다.
		------------+----------------+----------------------------------------------


	

		set/remove 태그]

		- <c:set/>은 setAttribute("속성명","값") 와 같은 역할. 
		
		<c:set var="EL변수명"  value="값" scope="영역"/>
		  
		- EL식에서 상요하는 EL 변수를 생성하는데 사용된다.

		- 변수에 값을 할당한다.
		  자바빈 이나 컬렉션과 같은 객체의 속성에 값을 할당하기
		  위해서는 target 과 property속성을 이용한다.

		  target과 property속성은 
		  자바빈이나 Map계열 개체에만 적용 할 수 있다.

		- 사용법

				- 변수에 일반적인 값 설정시

					<c:set 	
					var="값을 지정할 EL 변수명"  
					value="지정한 변수의 값"	
					[scope = "변수를 저장할 영역"]/>
					
						- value: 표현식,EL,정적인 텍스트를 사용하여 값을 지정 할 수 있다.	
						- scope: page/request/session/application 중 하나 기본값은 page.

				- 개체의 속성에 값 설정시
					※c:set 태그에서 var속성이 지정되어야만  scope속성을 넣을 수 있다.
					즉 step2]에서는 scope속성을 지정할 수 없다
					step1]<c:set  scope = "개체를 저장할 영역" var="객체변수"  value="<%=new Member()%>/>

					step2]<c:set 	target="var에서 설정한 자바빈 객체변수나 Map 객체변수" 
					               property="자바빈 객체나 Map 객체의 값을 설정할 속성명" 
							value="지정한 속성의 값"	
							/>

						- var속성은 추가하지 않는다.
						- target:표현식이나 EL변수를 지정한다
						
						* target이 자바빈 개체인 경우는 반드시 
						   그 클래스안에 set계열의 메서드가 정의 되어야 한다.
						  target이 Map인 경우는 put(키값(속성명),값)을 
						  이용해서 처리하는 것이다..


				
					※ <c:set>엘리먼트 사이에 Text를 value로 지정할 수도 있다</c:set>



				- set태그의 속성 요약

				--------------+----------------+------------------+-------------------------------------------
					속성	  |	  표현식/EL    |       타입       |                설명
				--------------+----------------+------------------+--------------------------------
					var       |      X		   |	   String	  |		  EL변수의 이름
				--------------+----------------+------------------+--------------------------------------------
					scope     |      X         |       String     |       변수를 생성할 영역.기본 값은 page
				--------------+----------------+------------------+----------------------------------------------
					value     |      O         |       Object     |       변수에 할당할 값
				--------------+----------------+------------------+------------------------------------------------
					target    |      O         |       Object     |       자바빈 개체 혹은 Map계열 컬렉션
				--------------+----------------+------------------+---------------------------------------------
					property  |      O         |       String     |       속성명
				--------------+----------------+------------------+-------------------------------------------------
			
			    *target에는 표현시과 EL만으로 개체를 지정 한다.
				*target에 표현식을 사용하는 경우는 개체가 자바코드로 생성 된 경우에만
				예]
					<cr:set var="map" value="<%=new Hashtable()%>"/>
					<cr:set target="${map}" property="name" value="홍길동"/>
					<cr:set target="${map}" property="info">
						우리시대의 마지막 남은 의적입니다.
					</cr:set>
					<cr:set target="${map}" property="age" value="남"/>  =>[O]
					<cr:set target="map" property="age" value="남"/>     
					=>[x] target에는 반드시 표현식이나 EL변수명
					<cr:set target="<%=map%>" property="age" value="남"/> 
					=>[x],단 <% Hashtable map=new Hashtable() %>인 경우는 가능


		


	
		remove 태그]

			- removeAttribute와 같은 역할
			- 해당 scope 에 있는 변수를 제거하는 역할을 한다.
			- 변수를 삭제하는 경우 scope이 맞지 않으면 삭제 되지 않는다.
			- scope를 지정하지 않으면 동일한 이름으로 저장된 모든 영역의 변수가 삭제 됨.

			-사용법

				<c:remove
				var="변수명" 
				[scope ="속성의 공유범위의 유효기간을 설정"]/>	


	

		if 태그]
			
			- <c:if/> 는 조건문을 사용하는 경우에 사용

			-사용법

				<c:if
				test="조건의 판별식"
				var="EL 변수명"			
				scope="변수의 공유범위를 지정"
				>
				
				-var 속성에는 test속성의 조건 결과가  저장됨(EL변수명)				
				-test속성에는 표현식,EL식 또는 정적 문자열이 올 수 있다.
				-test속성에 조건표시할때 빈 공백 들어가면 무조건 false
				 즉 test="${10 > 3}" }뒤에 빈 공백 제거해야 함

				예
				<c:if test="${param.name == 'hong'}" var="result" scope="session">
					홍길동 이군요
				</c:if>


	
		
		


		choose ~when ~otherwise 태그]

			-<c:choose/> 태그는 java 의 switch 문과 같지만, 
			  조건에 문자열 비교도 가능하고 쓰임의 범위가 넓다. 
			  또한 <c:if/> 태그에 else 가 없기 때문에 이의 대체 기능도 수행한다.
			- 하나 이상의 <c:when>, <c:otherwise>와 같은 sub tag를 갖을 수 있음.
			
			- 사용법
			<c:choose>
				<c:when test="조건1">조건1을 만족하는 경우</c:when>
				<c:when test="조건2">조건2을 만족하는 경우</c:when>
				<c:when test="조건3">조건3을 만족하는 경우</c:when>
				<c:otherwise>조건을 만족하지 않는 경우</c:otherwise>
			</c:choose>
		


		forEach태그]

			-  배열 또는 Collection또는 Map에 저장되어 잇는  
			    값들을 순차적으로 처리 할때 사용
			- for문과 확장 for문을 결합한 형태.

			- 사용법

				<c:forEach
				items="반복할 객체명"
				[begin="시작값"]
				[end="마지막 값"]
				[step="증가값"]
				var="변수명"   =>for(int i=1 ; i <=10;i++)일때 
				                        i가 1부터 1씩 증가하면서 10까지 변함
							이때 var속성에 i 변수를 넣는거다
							begin = "1"
							end = "10"
							step="1"
				[varStatus="LoopTagStatus 개체를 저장할 변수"] />

		

				items: 배열,Map,Collection만 올 수 있다.

				LoopTagStatus 개체의 속성

					index: [자바의 일반 for문 형태인 경우]
							-반드시 begin속성과 end속성 필요
							 step은 생략 가능(디폴트 1)
							 index는 begin 값 부터 변하는 값을 담고 있음.

							 var="변수명"   =>for(int i=1 ; i <=10;i++)일때 
				                        i가 1부터 1씩 증가하면서 10까지 변함
							이때 var속성에 i 변수를 넣는거다
							begin = "1"
							end = "10"
							step="1"

						 [확장 for문 형태 즉 컬렉션이나 배열에서 값 꺼내올때]
							-var 와 items속성은 필수
						        -index는 0부터 시작

							자바 확장for문]
							for(컬렉션 혹은  배열에 들어 있는 클래스타입  변수 : 컬렉션 혹은 배열명){


							}

							var="변수명" =>변수
							items =>컬렉션 혹은 배열명

					count:반복 실행 횟수(1부터)
					begin:begin 속성값
					end:end 속성값
					step:step속성값(디폴트 값은 1)
					first:현재 실행이 첫번째 실행인 경우 true
					last:현재 실행이 반복의 마지막 실행인 경우true
					current:컬렉션중 현재 루프에서 사용할 개체

			
				--------------+----------------+------------------+-------------------------------------------
					속성	  |	  표현식/EL    |       타입       |                설명
				--------------+----------------+------------------+--------------------------------
					var       |      X		   |	   String	  |		  EL변수의 이름
				--------------+----------------+------------------+--------------------------------------------
					items     |      O         | 컬렉션,배열,Map등|       반복 처리할 데이타
				--------------+----------------+------------------+----------------------------------------------
				 varStatus    |      X         |       String     |       반복정보를 저장할 EL변수명
				--------------+----------------+------------------+------------------------------------------------
					begin     |      O         |       int        |       시작인덱스 값
				--------------+----------------+------------------+---------------------------------------------
					end       |      O         |      int         |       종료 인덱스 값
				--------------+----------------+------------------+-------------------------------------------------
					step      |      O         |      int         |       인덱스 증가분
				--------------+----------------+------------------+-------------------------------------------------

			

		forTokens 태그]

			-StringTokenizer 를 사용하는 것과 동일한 기능
			-사용법
               123-123-4444
				<c:forTokens
				items="문자열"
				delims="문자열을 구분할 구분자"
				[begin="반복할 시작값"]
				[end="반복할 마지막 값"]
				[step="증가값"]
				var="변수명"
				[varStatus="LoopTagStatus 개체를 저장할 변수"]
				

				*items에는 문자열이 와야 한다.
				forEach태그처럼 배열이나 Collection등이 올수 없다.

			
			<c:forTokens var="color" items="red,yellow,black" delims=",">
				<c:out value="${color}">
			</c:forTokens>

		import 태그]

			- <jsp:include>액션 태그와 동일하다!
			- 동일한 웹 어플리케이션의 자원 뿐만 아니라, 
			   FTP, HTTP 와 같은 외부 자원도 가져와 현재 위치에
			  삽입하거나 EL변수에 정장할때 사용.
			 
			- 사용법
				<c:import
				url="url"
				[var="읽어올 데이터를 저장할 변수명"]
				[scope="변수의 공유범위"]				
				[charEncoding="읽어온 데이터의 Character set을 지정"] />

				*var속성을 사용하는 경우  읽어온 데이타를 현재 위치에 바로 삽입하지 않고
				   EL변수에 저장된 값을 사용할때 삽입돈디.
				*var속성을 이용하지 않은 경우 <jsp:include>액션 태그와 동일하다

				*요청 파라미터는 직접 url에 추가하거나 <c:param name="파라미터명" value="값"/>을 
				  잉요해서 추가 할 수 있다.

				*url속성과 charEncoding속성은 표현시과 EL표현이 가능하다.
				


		redirect 태그]

			-response.sendRedirect 기능
			-request를 공유하지 않는다.
			단,response.sendRedirect 와는 다르게 이후의 코드는 실행하지 않는다.

			-<c:param>태그를 이용해서 파라미터를 url에 추가 할 수 잇다.
			- 사용법
				<c:redirect
				url="이동할 URL" [context="컨텍스트경로"] />

				*url이 / 로 시작할 경우 현재 컨텍스트 경로가 추가되서 리다이렉트 하고
				만약 다른 컨텍스트 경로로 리다이렉트 하고 싶다면 context속성에 추가 해 준다.

				*<c:redirect>태그가 실행되면 그 이후의 코드는 실행되지 않는다.

				<c:redirect url="/다른 컨텍스트에 있는 jsp" context="/다른 컨텍스트명"/>

				*url 및 context속성은 표현식/EL표현이 가능.

		
		url 태그]

			

			-Query paramter로 부터 url을 생성한다.
			-<c:param>태그를 이용해서 파라미터를 url에 추가 할 수 잇다.

			-var속성을 지정하지 않은 경우 현재 위치에 url을 출력하고 ,
			지정한 경우에는 해당 EL변수에 저장된다
			-사용법
				<c:url
				[var="EL 변수명"]
				value="생성할 URL"
				[scope="변수간의 공유 범위"] />


				<c:url value="/customer/register" var="registrationURL"
					<c:param name="name" value="${param.name}"/>
					<c:param name="country" value="${param.country}"/>
				</c:url>



		   out 태그]


			- JSP의 표현식을 대체하는 것으로 사용함. 화면에 해당하는 변수의 값을 출력한다.
             
			- 사용법
				<c:out
				value="출력할 값" 
				[default="기본값을 설정"] -즉 value에 지정한 값이 없을 경우 ,default에 지정한 값이 출력됨
				[escapeXml="특수문자 처리유무"] />
				
				*value는 일반적으로 문자열이나
				Reader개체가 들어오면 out태그는 Reader로부터 값을 읽어와 
				jspWriter로 값을 출력하낟.

				* escapeXml 이 true인 경우 <,>,&,’," 를 &lt; &gt; &amp; &#039; &#034로 출력(기본값이 true)

				
				<c:out value="${browser}" escapeXml="true" />

			catch 태그]
		
				- body 위치에서 실행되는 코드의 예외를 catch 하는 역할

				- 사용법
				<c:catch
				var="EL 변수명">
				에러가 발생한 경우 지정한 EL 변수에 에러메시지가 저장된다.

				*EL은 에러에 관대하기때문에 주로 자바코드에서 
				나는 에러는 처리 할때 사용된다.

				
				<c:catch var="errMsg" >


					예외가 발생할 수 있는 코드

				</c:catch>


				${errMsg}


		국제화 태그]

			formatNumber 태그]

				- 숫자를 양식에 맞춰 문자열로 변환해주는 태그

				<fmt:formatNumber value="숫자값"  [type="값 타입"]
				                  [currencySymbol="통화 심벌"]  
								  [groupingUsed="(true/false)"]
						          [var="변수명"] [scope="영역"]

				- var 와 scope속성을 제외한 모든 속성은 EL식과 표현식 지정 가능

				-type: number :숫자 형식으로 출력(기본값)
				       percent: %형식으로 출력
					  currency:통화 형식으로 출력
					  type이 percent일때 value속성에 지정한 값에 100을곱한거와 같다
				-currencySymbol :통화 출력시 사용할 기호 표시
							(type이 currency일때 의미 있음)
                                                        예] currencySymbol="$"
							     미 지정시 현지 통화 심벌로 출력(한국:\(원 표시)등)

                               
				-groupingUsed:콤마(,)와 같이 단위를 구분할때 
				                     사용되는 기호를 사용할 지의 여부
				                     기본값 true
				-var: 포맷팅한 결과를 저장할 변수명 ,
				        var 속성을 지정하지 않는 경우 곧바로 출력 됨


			formatDate 태그]

				- 문자열로 표시되는 날짜 및 시간 값을 java.util.Date로 파싱해주는 기능
				- var 와 scope속성을 제외한 모든 속성은 EL식과 표현식 지정 가능

				<fmt:formatDate value="날짜값" [type="타입"]
				             [dateStyle="날짜스타일"] [timeStyle="시간 스타일"]
							 [pattern="패턴문자열"]
							 [var="변수명"] [scope="영역"]/>
							 
				
				value: 포맷팅할 날짜 및 시간 문자열 값(java.util.Date타입 지정)
				type: 날짜,시간 또는 둘다를 포맻?할지를 결정
				        time,date(기본값),both 값중 하나 지정

				dateStyle:날짜에 대해 미리 정의된 포맷팅 스타일을 지정
				        default(기본값),short,medium,long,full중 하나 지정
					
				timeStyle:시간에 대해 미리 정의된 포맷팅 스타일을 지정
					    default(기본값),short,medium,long,full중 하나 지정
				pattern:
				날짜형식을 패턴에 맞게 출력 java.util.SimpleDateFormat의 패턴 참조
					   예] "yyyy-MM-dd HH:mm:ss"

					  ※ pattern속성 지성시 type은 의미 없음 즉 pattern에
		                             지정된 형식대로 출력됨.
				

		JSTL 함수]

			length(obj):obj가 Collection인 경우 저장된 항목의 개수를 리턴,
			                 문자열인 경우 문자열의 길이를 리턴
			toUpperCase(str):문자열을 대문자로 변환
			toLowerCase(str):문자열을 소문자로 변환
			substring(str, idx1, idx2):str.substring(idx1,idx2)의 결과를 리턴.
			                                   idx2가 -1일 경우 str.substring(idx)와 같다
			substringAfter(st1, str2):str1에서 str1에 포함되어 있는 str2이후의 문자열을 구한다
			substringBefore(str1, str2):str1에서 str1에 포함되어 있는 str2이전의 문자열을 구한다
			trim(str):str좌우의 공백 문자 제거			
			replace(str, src, dest):str에 있는 src를 dest로 변환
		
			indexOf(str1, str2):str1에서 str2가 위치한 인덱스를 구한다
			startsWith(str1, str2):str1이 str2로 시작할 경우 true,아니면 false
			endsWith(str1, str2):str1이 str2로 끝날 경우 true,아니면 false
			contains(str1, str2):str1이 str2를 포함하고 잇을 경우 true,아니면 false
			split(str1, str2):str2를 기준으로 str1을 분래해서 배열로 리턴
			join(array,str2):array에 저장된 문자열을 합치는데 각 문자열 사이에 str2가 붙는다
			escapeXml(str):특수문자 처리 예를들면 < 는 &gt; 로 변환




[커넥션 풀(Connection Pool)]

	-커넥션 풀이란?
		
		웹 환경에서 처럼 데이타베이스와의 연결이 빈번하게 발생하는 경우,
		그때마다 커넥션을 생성하고 닫게 되면
		리소스의 낭비와 연결시 시간소비를 하게 된다
		이를 개선하기 위해 미리 커넥션을 생성해 pool에 넣어 놓고 요청이 
		잇으면 커넥션을 pool에서 가져다 쓰고
		다 쓰고 나면 다시 pool에 반납한다. 이런 기법을 커넥션 풀이라 한다.

	-아파치에서 제공하는 커넥션 풀(DBCP) 사용하기

		-DBCP관련 API를 위한 환경 설정(Tomcat 5.5이상버전에서는 아래 사항 생략
		-[톰캣설치된 디렉토리]/lib/tomcat-dbcp.jar에 포함되어 있음)

			- commons-dbcp package다운로드
				http://commons.apache.org/ ->DBCP클릭->downloads클릭->latest Release 클릭
				Commons DBCP 1.4 for JDBC 4 (JDK 1.6)의 commons-dbcp-1.4-bin.zip다운로드

			*The commons-dbcp package relies on code in the commons-pool package to provide the underlying object pool mechanisms that it utilizes.
			
			- commons-pool package다운로드
				http://commons.apache.org/ ->POOL클릭->downloads클릭-> Apache Commons Pool Downloads page 클릭
				Commons Pool 1.6의 commons-pool-1.6-bin.zip다운로드

			->압축을 풀고 commons-dbcp-1.4.jar와 commons-pool-1.6.jar를 WEB-INF/lib에 복사한다
		
			※DBCP 1.4는 JDK 1.6에서만 DBCP 1.3는 JDK 1.5이하 에서만 실행됨

		

		[JNDI(Java Naming Directory Interface)를 이용한 DBCP설정]

		   -톰캣이 스타트 하면서 톰캣버전/conf/server.xml과 context.xml에 설정한 대로 
		    커넥션풀을 생성하고 사용자는 생성된 커넥션풀에서 커낵션 개체를 가져다 쓰면 된다.
		    (JNDI를 이용해서 가져다 씀)@@@
		   -최종적으로 데이타의 근원지 즉 데이타소스를 얻어와(lookup해서) 커넥션 개체를 얻어 올 수 있다.

			*Reference URL

			www.apache.org->Tomcat프로젝트 클릭->
			좌측 Document메뉴의 톰캣버전 클릭->JNDI Resources 클릭
			
			JNDI 코드 예시
			http://tomcat.apache.org/tomcat-6.0-doc/jndi-datasource-examples-howto.html

			1] DBCP관련 API를 위한 환경 설정

					

					- commons-dbcp package다운로드
							www.apache.org의 commons프로젝트 선택
						http://commons.apache.org/ ->DBCP클릭->downloads클릭->latest Release 클릭
						Commons DBCP 1.4 for JDBC 4 (JDK 1.6)의 commons-dbcp-1.4-bin.zip다운로드

					*The commons-dbcp package relies on code in the commons-pool package to provide the underlying object pool mechanisms that it utilizes.
					
					- commons-pool package다운로드
						http://commons.apache.org/ ->POOL클릭->downloads클릭-> Apache Commons Pool Downloads page 클릭
						Commons Pool 1.6의 commons-pool-1.6-bin.zip다운로드

					->압축을 풀고 commons-dbcp-1.4.jar와 commons-pool-1.6.jar를 WEB-INF/lib에 복사한다 혹은 jdk-버전/jre/lib/ext에 복사한다.
				
					※DBCP 1.4는 JDK 1.6에서만 DBCP 1.3는 JDK 1.5이하 에서만 실행됨


			2])Tomcat버전/conf/server.xml의 <GlobalNamingResources>태그 사이에 세팅
			
				--어느 웹 어플리케이션이든지 위에서 등록한 이 리소스를 사용하게 할 수 있도록 
		 
		 
				<Resource auth="Container"
				driverClassName="oracle.jdbc.driver.OracleDriver" 
				maxTotal="20" maxIdle="20" 
				name="jdbc/myoracle" password="tiger" 
				type="javax.sql.DataSource"
				url="jdbc:oracle:thin:@127.0.0.1:1521:orcl" 
				username="scott"/>
			


				initialSize - The initial number of connections that will be created in the pool during pool initialization. Default: 0
				maxTotal - The maximum number of connections that can be allocated from this pool at the same time. Default: 8
				minIdle - The minimum number of connections that will sit idle in this pool at the same time. Default: 0
				maxIdle - The maximum number of connections that can sit idle in this pool at the same time. Default: 8
				maxWaitMillis - The maximum number of milliseconds that the pool will wait (when there are no available connections) for a connection to be returned before throwing an exception. Default: -1 (infinite)



			3]Tomcat버전/conf/context.xml의 <Context reloadable="true"> 태그 사이에 아래부분 세팅
		 
				<ResourceLink global="jdbc/myoracle"
				name="jdbc/myoracle"
				type="javax.sql.DataSource"/> 

			4] 자바코드에서 아래와 같이 코딩
				
				javax.naming.*와 javax.sql.*,java.sql패키지 import
		 
				InitialContext initContext = new InitialContext();
				//JNDI서버스의 루트를 얻고(NamingException발생)
				//Context envContext  = (Context)initContext.lookup("java:/comp/env");
				//Tomcat서버의 서비컨텍스트를 얻어서
				//DataSource ds = (DataSource)envContext.lookup("jdbc/myoracle");//톰캣의 server.xml과 context.xml에 등록한 이름을 찾는다.

				혹은
				DataSource ds =(DataSource)initContext.lookup("java://comp/env/jdbc/myoracle");

				Connection con = ds.getConnection();//데이타소스로 커넥션풀에서 커넥션 개체를 얻어 옴.
				                                                             
			
			*위와 같이 해도 안되면 web.xml에 아래 내용 추가
				<web-app> 태그사이에 아래 부분 세팅
		 
				<resource-ref> 
					<description>Oracle Datasource example</description> 
					<res-ref-name>jdbc/myoracle</res-ref-name> 
					<res-type>javax.sql.DataSource</res-type> 
					<res-auth>Container</res-auth> 
				</resource-ref>  

			*JNDI(java naming directory interface):
			 네이밍 서비스(DNS-Domain Name Server) 처럼 분산된 객체를 찾기위해 특정한 이름으로 
			 객체를 등록해서 관리 할 수 잇게 도와주는 서비스
			  즉 네이밍서버에 여려 객체를 등록할때 이름으로 매핑하여 등록하고 
			  다른 프로그램에서 그 객체를 찾을때는
			  해당 이름으로 찾아서(lookup) 사용한다.


			  1]Java Naming and Directory Interface의 약자
			  2] 명명 및 디렉토리 서비스에 접근하기위한 API
			  3] 개발자는 개체를 등록(bind,rebind)하고 찾아 쓰는(lookup)방법만 알면 된다
			  4] 서버에 JNDI Driver(service provider라 부름)만 있으면 명명/디렉토리 서비스를
				 이용할 수 잇다. JNDI드라이버는 우리가 호출한 이름을 Naming서비스에서 
				 이해 할 수 있는것으로
			 바꿔주는 역할 을 한다.
			 대부분의 WAS서버들은 JNDI드라이버를 가지고 있다.
			  5] JNDI의 구조는 윈도우 탐색기처럼 트리 구조를 가지고 있다. 
				 JNDI트리를 들어갈때는 우선 
				 InitialContext(javax.naming패키지)에서 시작한다.         
			   6] InitialContext에서 시작하지만 WAS서버마다 자기만의 JNDI컨텍스트가 있다.
				  바로 이 JNDI컨텍스트에서 찾고자하는 검색작업은 
				  java:comp/env(Tomact서버의 경우)라는 서브 컨텍스트에서 시작된다.
				  즉 JNDI의 트리구조에서 InitialContext->java:comp/env->우리가 server.xml에 등록한 JNDI명을 찾는다.


	
[초기화 파라미터를 이용한 JDBC드라이버 로딩]

	- 웹 어플리케이션의 환경설정 파일인 web.xml에 초기화 파라미터를 설정하여 
	  웹 어플리케이션이 구동시 자동으로 JDBC드라이버를 한번만 로딩하도록 구현.


	  구현 순서]

		  1)web.xml에 서블릿 설정

			-초기화 파라미터 설정
			-서블릿 로드 우선순위 설정

				<servlet>
						<servlet-name>JDBCDriver</servlet-name>
						<servlet-class>myjdbc.driver.FirstLoadDriver</servlet-class>						
						<load-on-startup>1</load-on-startup><!-- 웹 어플리케이션 구동시 이 서블릿의 init()메서드를 가장 먼저 실행하라는 의미-->
				</servlet>
				<context-param>
						<param-name>jdbcDriver</param-name>
						<param-value>oracle.jdbc.driver.OracleDriver</param-value>	
				</context-param>


		  2)서블릿 클래스의 init()메서드를 오버라이딩
		  
			-init()메서드에서 JDBC드라이버를 로딩

				package myjdbc.driver;

				import javax.servlet.*;
				import javax.servlet.http.*;
				import java.util.*;


				public class FirstLoadDriver extends HttpServlet{

					public void init() throws ServletException{

						try{
							
							String drivers =getServletContext().getInitParameter("jdbcDriver");
							StringTokenizer st = new StringTokenizer(drivers);
							while(st.hasMoreTokens()){

								String driver = st.nextToken();
								Class.forName(driver);
							}

						}
						catch(Exception e){

							throw new ServletException(e);

						}
						


					}

				}

		  3) WEB-INF/classes에 위치 하도록 서블릿 클래스를 컴파일

				.java위치디렉토리>javac -d ../classes  FirstLoadDriver.java

				WEB-INF +---classes
				        +---src----FirstLoadDriver.java

		  4)데이타베이스 연결과 관련된 페이지에서는 Class.forName()없이 DriverMabager.getConnection()으로
		    커넥션 개체를 얻는다.

			
			Connection con = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:데이타베이스명","아이디","패스워드");


		※컨텍스트 초기화 파라미터:
		 -<context-param>엘리먼트로 web.xml에 설정
		 - 해당 컨텍스트(웹 어플리케이션)를 구성하는 모든 서블릿이 공유
		 - 읽을때:ServletContext타입의 getInitParameter("컨텍스트 초기화 파라미터명")
		 ※서블릿 초기화 파라미터
		 -<servlet>엘리먼트의 하위엘리먼트로
		  <init-param>엘리먼트롤 추가해서 web.xml에 설정
		 -해당 서블릿만 사용 가능
		 -읽을때:ServletConfig타입의 getInitParameter("서블릿 초기화 파라미터명")
		 
		 ※ServletContext는 컨텍스트 즉 웹 어플리케이션당 하나
		  ServletConfig 는 서블릿당 하나. 		  	 

[파일 업로드]


	- form의 Method속성는 반드시 post방식으로 post방식일 경우 2가지 형태의 인코딩 방식이 있는데
	 	
	    1) application/x-www-form-urlencode: 파일 이름만 전송됨(디폴트값)
	    2) multipart/form-data: 파일이름과 함께 파일 데이타가 전송된다

	- form의 enctype은 multipart/form-data로 지정해야 한다.
	- form의 하위 요소로는  <input type=file> 사용

	- form에서 encytype을 "multipart/form-data"로 설정하는 경우,
	   사용자가 입력하는 내용과 업로드되는 파일 내용은 한번에
	  서버에 전달된다.  이 때 사용자가 입력한 내용과 파일 내용을 구분하기 위해
	  특수 문자를 사용하는데 이것을 boundary라고 한다.
	  바운더리 문자는 "--"로 시작한다.
 

	MultipartRequest API를 이용한 업로드]

		-API다운로드 및 환경 설정

			1)http://www.servlets.com/cos/->cos-26Dec2008.zip 다운로드

			2)압축을 푼다.

			3)lib폴더에 있는 cos.jar파일을 복사 하여 WEB-INF/lib폴더에 붙여 넣는다.
			(배포 목적)

			  이클립스나 직접 javac컴파일에서 사용하려면
			  [jdk폴더]\jre\lib\ext와 [톰캣이설치된 디렉토리]\lib에도 붙여 넣는다.


			※ jsp페이지에서 com.oreilly.servlet 패키지 와 
			  com.oreilly.servlet.multipart패키지를
                            import하여 API를 사용한다.

			   com.oreilly.servlet.multipart패키지에는 
			   파일중복시 자동으로 인덱스를 부여하여 생성하는 클래스를 제공해준다.
			   (FileRenamePolicy 와 DefaultFileRenamePolicy )


	
		- 생성자

			MultipartRequest(
			javax.servlet.http.HttpServletRequest request,
			java.lang.String saveDirectory) 

	 
			saveDirectory 디렉토리에 파일을 업로드하는 객체를 생성한다.
			업로드 되는 파일 최대크기는 1MB. 
			크기가 초과될 때는 IOException이 발생됨.
			업로드되는 파일이름에 현재시간에 해당하는 숫자가 붙어 저장된다.
	 
			MultipartRequest(javax.servlet.http.HttpServletRequest request,
			java.lang.String saveDirectory,
			int maxPostSize,
			java.lang.String encoding,
			FileRenamePolicy policy) 
			
			최대 크기가 maxPostSize 바이트이고 
			saveDirectory 디렉토리에 파일을 업로드하는데 캐릭터세은 
			encoding으로 정해주고
			중복된 파일이 있으면 파일 재정의 정책을 사용하는 객체를 생성.
	 
			※파일용량 초과시 에러 즉 MultipartRequest객체가
			  생성이 안됨.
                          단, 파일 미 첨부시에는 MultipartRequest객체 생성되나
			  MultipartRequest의 getFilesystemName("파라미터명")로
			  값을 읽어올때 null임.
			
			- 주요 메소드

			String getContentType(name : String): 파일의 MIME타입을 리턴
			File getFile(name : String): 업로드되어 서버에 저장된 파일의 File객체를 리턴
			Enumeration getFileNames(): 업로드된 모든 파일의 이름을 리턴
			String getFilesystemName(name : String): 업로드된 파일의 파일 이름을 리턴. 
			중복된 파일을 올릴 경우 새롭게 재정의된 파일이름 리턴
			String getOriginalFileName(name: String): 재정의 되기 전의 원래 파일명 리턴
			String getParameter(name : String): 클라이언트로부터 전달된 파라미터 값을 리턴(다른 폼 요소 얻어 올때)
			Enumeration getParameterNames(): 클라이언트로부터 전달된 파라미터 이름을 리턴
		



			*MultipartRequest 개체를 생성함으로써 업로드가 이루어진다.
			*파일명을 얻어 올때는 getFilesystemName()메서드로 
			 다른 폼요소의 값을 얻어 올때는 getParameter()로 얻어 온다.
			*저장된 파일과 얻어온 파일명의 차이
 

* MVC방식의 Model에 속하는 DAO 및 DTO정의

   Model: 업무처리 로직을 담당하거나 혹은 데이타 베이스와 관련된 작업을 담당.
   View: 사용자에게 보여지는 부분을 담당(예:JSP페이지)
   Controller: Model과 View를 제어
                   예] 사용자의 요청을 받아서 그 요청을 분석하고
		   필요한 업무처리로직을 호출(Model)하여 결과값을 Model로부터 받아서
		   사용자에게 그 결과 값을 보여줄 View(jsp페이지)를 선택하는 역할 담당


   DAO:(Data Access Object) 
           -Model에 속함
	   -데이타베이스에 액세스 해서 데이타 베이스와 관려된 업무처리 로직 즉
	    입력/수정/삭제/조회등의 업무를 처리

  DTO(Data Transer Object)
	-Model에 속함
	-데이타를 전달하는 객체
	-예] 데이타베이스의 테이블을 클래스화 한것


   
※텔넷으로 페이지 요청해서 응답헤더 및 응답바디 보기

1]dos>telnet 서버명 포트 [엔터]

2]GET 도메인을 제외한 절대경로  HTTP/1.0 [엔터두번]  --입력 내용이 안보임
예]
dos>telnet localhost 8080 [엔터]
GET  /InnerObject/SetHeaderOfResponse.jsp HTTP/1.0 [엔터두번]


※링크걸기
HTML태그: 컨텍스트 루트를 포함한 /로 시작하는 절대경로
                   예] <a href="${pageContext.request.contextPath}/폴더명1/폴더명2/요청명">

web.xml: 요청명을 서블릿과 매핑 시킬때
                  컨텍스트 루트를 제외한 /로 시작하는 요청명 경로

                 예]  <url-pattern>/폴더명1/폴더명2/요청명</url-pattern>

서블릿 자바 클래스:

                   forward방식으로 VIEW(JSP페이지)로 이동하는 경우 :   컨텍스트 루트를 제외한 /로 시작하는 JSP페이지 경로
                   예] req.getRequestDispatcher("/폴더명1/폴더명2/view.jsp").forward(req,resp);
                   redirect방식으로 VIEW(JSP페이지)로 이동하는 경우 :  컨텍스트 루트를 포함한 /로 시작하는 JSP페이지 경로
                   예] resp.sendRedirect(req.getContextPath()+"/폴더명1/폴더명2/view.jsp");